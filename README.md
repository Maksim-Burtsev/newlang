# Проект *NewLang*
*NewLang* - это язык программирования высокого уровня в котором можно сочетать стандартные алгоритмические конструкции 
с декларативным программированием и тензорными вычислениями для задач машинного обучения.

Основной особенностью языка является легкий, логичный и не противоречивый синтаксис, 
который основан не на использовании зарезервированных ключевых слов, а на строгой системе грамматических правил 
с использованием знаков препинания (в список которых входят и операторы языка).

## Основные свойства и особенности языка:
- Возможность работы как в режиме интерпретатора, так и компилятора
- Динамическая и статическая типизация с возможностью указания типов в явном виде. 
Статическая типизация является условно строгой (автоматическое приведение типов отсутствует, но допускается преобразование 
между некоторыми типами данных, например, целое число может быть автоматически преобразовано в вещественное, но не наоборот)
- Автоматическое управление памятью
- ООП в виде явного наследования классов и [«утиная»](https://ru.wikipedia.org/wiki/%D0%A3%D1%82%D0%B8%D0%BD%D0%B0%D1%8F_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F) типизация
- На уровне синтаксиса поддержка нескольких типов функций (обычные и [чистые функции без побочных эффектов](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D1%82%D0%BE%D1%82%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8))
- Необязательные и именованные параметры функций
- Возможны вставки кода на языке реализации (С/С++)
- Простая интеграция с уже существующими программными библиотеками (в том числе импорт нативных переменных и функций из С/С++.)
- Имеется REPL [read-eval-print loop — «цикл: чтение — вычисление — вывод»](https://ru.wikipedia.org/wiki/REPL)

## Зачем нужен *NewLang*?
У всех современных языков программирования происходит постоянное ~~развитие~~ усложнение синтаксиса по мере выхода новых версий. 
Это является свое рода платой за появление новых возможностей и воспринимается пользователями как естественное явление. 

Но одновременно является и серьезной проблемой, т.к. с выходом новых стандартов и добавления новых ключевых слов и синтаксических конструкций, 
неизбежно повышается и порог входа для новых пользователей. Еще одним следствием этого процесса становится постоянное повышение 
сложности разработки и трудоемкости поддержки уже созданных программных продуктов, когда старый код дорабатывается с применением новых стандартов.

У *NewLang* сложность языковых конструкций естественно ограничена за счет разделения синтаксиса языка на две части, что упрощает его изучение и использование. 
*Основной синтаксис* — для написания программ в объектно-ориентированном (императивном) и декларативном стилях и 
*Расширенный синтаксис* — когда основного синтаксиса становится недостаточно, например для использования отдельных языковых конструкций языка реализации. 

Еще одно неудобство мейнстримовых языков, большинство из них были созданы до начала эпохи машинного обучения, 
поэтому тензорные вычисления у них выполнены в виде отдельных библиотек, а не встроены в основной синтаксис языка и систему базовых типов.
У *NewLang* тензорные вычисления доступны «из коробки» (используется библиотека [libtorch](https://pytorch.org/)),
а арифметические типы данных являются скалярами (тензорами нулевой размерности).

### Основной синтаксис
Основной синтаксис *NewLang* - простой и логичный за счет того, что он построен исключительно на грамматических правилах 
и не использует каких либо зарезервированных ключевых слов, а все буквенно-символьные последовательности рассматриваются 
как идентификаторы в которых можно использовать любые не-ASCII символы.

Названия встроенных типов или имена служебных функции системной библиотеки определяются конкретной реализацией языка, поэтому не
являются зарезервированными ключевыми словами и при необходимости могут быть переопределены, например, для создания собственного, 
предметно-ориентированного диалекта (DSL - domain-specific language), если в этом возникнет необходимость. 
Но сама структура программы и логика выполняемого алгоритма все равно останутся понятны всем, кто знаком правилами основного синтаксиса *NewLang*.

### Расширенный синтаксис
Расширенный синтаксис — это возможность вставить в текст программы *NewLang* исходнй код на языке реализации, 
что позволяет использовать практически любые возможности С/С++. 

Обработка расширенного синтаксиса происходит на этапе компиляции приложения, а взаимодействие между основным 
и расширенным синтаксисами происходит за счет совместного использования идентификаторов, 
которое полностью прозрачно для пользователя и подчиняется единым грамматическим правилам основного синтаксиса.

#### Пример скрипта Hello world! на NewLang
    #!./nlc --eval 
    # Определение функции hello
    hello(str) := { 
      printf := @import('printf(format:Format, ...):Int');  # Импорт стандартной C функции
      printf('%s\n', $str);  # Вызов C функции с проверкой типов аргументов по строке формата
    };
    hello('Привет, мир!'); # Вызвать функцию

Вывод: `Привет, мир!`

### Еще немного примеров:
Любая последовательность вычислений возвращает результат выполнения последнего оператора.
Поэтому выполнение одной команды или последовательности команд всегда возвращает какой либо результат,
а оператор возврата из функции необязателен, так как результатом будет значение последнего вычисленного выражения.

#### Создание переменных
    > scalar := 42
    42

    > tensor := [1,2,3,4,5,]  # Тип тензора выводится автоматически
    [1, 2, 3, 4, 5,]:Char
               
    > str := '$1 string'
    $1 string

#### Арифметические операции
    > tensor * 2
    [2, 4, 6, 8, 10,]:Short
    
    > tensor * 20
    [20, 40, 60, 80, 100,]:Short
    
    > tensor * 0.5
    [0.5, 1, 1.5, 2, 2.5,]:Double
    
    > tensor / 2 # Результата деления — число с плавающей точкой
    [0.5, 1, 1.5, 2, 2.5,]:Double

    > tensor // 2 # Целочисленное деление без остатка
    [0, 1, 1, 2, 2,]:Char

    > tensor % 2 # Целочисленный остаток от деления
    [1, 0, 1, 0, 1,]:Char
    
#### Строковые операции
    > str = 'сцепеление строк ' ++ str
    сцепеление строк $1 string

    > str('строка как шаблон')
    сцепеление строк строка как шаблон string
   
#### Преобразование тензоров
В эпоху машинного обучения тензоры являются основным элементом вычислений, поэтому для конвертирования данных в тензоры
используется отдельная синтаксическая конструкция, состоящая из двойных квадратных скобок **[[** *данные* **]]**.
Подробнее про особенности преобразования типов можно посмотреть в [полном описании синтаксиса](https://github.com/rsashka/newlang/blob/dev/Syntax.md).
  
    > tstr := [["Тест"]]   # Создать тензор из строки широких символов
    [1058, 1077, 1089, 1090,]:Int

    > t2 := [[ "Тест" ]]:Int[2,2] # Тоже самое, но тензор двухмерный
    [
      [1058, 1077,], [1089, 1090,],
    ]:Int

    > StrWide(tstr) # Конвертировать тензор обратно в строку
    Тест

    > Double(t2)    # Изменить тип данных тезора
    [
      [1058, 1077,], [1089, 1090,],
    ]:Double

    > t3 := [[ t2 ]]:Char[4] # Преобразовать тип данных тензора и его размерность
    [34, 53, 65, 66,]:Char


## [Полное описание синтаксиса](https://github.com/rsashka/newlang/blob/dev/Syntax.md)


### Сборка REPL из исходников (пока только под Linux)
#### Подготовка репозитория
- Скачать исходники [https://github.com/rsashka/newlang](https://github.com/rsashka/newlang)
- Скачать и развернуть архив [libtorch](https://pytorch.org/) в каталоге *contrib* (PyTorch Build: Stable (1.10.*) -> Your OS: Linux -> Package: LibTorch -> Language: C++ / Java -> Compute Platform: CPU -> Download here (cxx11 ABI):
[libtorch-cxx11-abi-shared-with-deps-1.10.2+cpu.zip](https://download.pytorch.org/libtorch/cpu/libtorch-cxx11-abi-shared-with-deps-1.10.2%2Bcpu.zip))
- Активировать и скачать исходники субмодулей (`git submodule init && git submodule update`)
- В каталоге *contrib* запустить файл `build.sh` для сборки библиотеки libffi

### Собрать
- Юнит-тесты: в каталоге *core* выполнить команду **`make CONF=UnitTest`**
- интерпретатор nlc: в каталоге *core* выполнить команду **`make CONF=Debug`**
