# Проект *NewLang*
*NewLang* - это язык программирования высокого уровня в котором можно сочетать стандартные алгоритмические конструкции 
с декларативным программированием и тензорными вычислениями для задач машинного обучения.

Основной особенностью языка является легкий, логичный и не противоречивый синтаксис, 
который основан не на использовании зарезервированных ключевых слов, а на строгой системе грамматических правил 
с использованием знаков препинания (в список которых входят и операторы языка).

## Основные свойства и особенности языка:
- Возможность работы как в режиме интерпретатора, так и компилятора
- Динамическая и статическая типизация с возможностью указания типов в явном виде. 
Статическая типизация является условно строгой (автоматическое приведение типов отсутствует, но допускается автоматическое 
преобразование между некоторыми типами, например, целое число может быть автоматически преобразовано в вещественное, но не наоборот)
- Автоматическое управление памятью
- ООП в виде явного наследования классов и [«утиная»](https://ru.wikipedia.org/wiki/%D0%A3%D1%82%D0%B8%D0%BD%D0%B0%D1%8F_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F) типизация
- На уровне синтаксиса поддержка нескольких типов функций (обычные и [чистые функции без побочных эффектов](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D1%82%D0%BE%D1%82%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8))
- Возможны вставки кода на языке реализации (С/С++)
- Простая интеграция с уже существующими программными библиотеками (в том числе импорт нативных переменных и функций из С/С++.)

## Зачем нужен *NewLang*?
У всех современных языков программирования происходит постоянное ~~развитие~~ усложнение синтаксиса по мере выхода новых версий. 
Это является свое рода платой за появление новых возможностей и воспринимается пользователями как естественное явление. 

Но одновременно является и серьезной проблемой, т.к. с выходом новых стандартов и добавления новых ключевых слов и синтаксических конструкций, 
неизбежно повышается и порог входа для новых пользователей. Еще одним следствием этого процесса становится постоянное повышение 
сложности разработки и трудоемкости поддержки уже созданных программных продуктов.

У *NewLang* сложность языковых конструкций естественно ограничена, что упрощает его изучение и использование. 
Это реализуется за счет разделения синтаксиса языка на две части. 
*Основной синтаксис* — для написания программ в объектно-ориентированном (императивном) и декларативном стилях и 
*Расширенный синтаксис* — когда основного синтаксиса становится недостаточно, например для использования отдельных языковых конструкций языка реализации. 

Еще не стоит забывать, что мейнстримовые языки были созданы до начала эпохи машинного обучения 
и тензорные вычисления у них выполнены в виде отдельных библиотек, а не встроены в основной синтаксис языка и систему базовых типов.
У *NewLang* тензорные вычисления доступны «из коробки» (используется библиотека [libtorch](https://pytorch.org/)),
а арифметические типы данных являются скалярами (тензорами нулевой размерности).

### Основной синтаксис
Основной синтаксис *NewLang* является простым и логичным за счет того, что он построен исключительно на грамматических правилах 
и не содержит каких либо зарезервированных ключевых слов. А все буквенно-символьные последовательности рассматриваются 
как идентификаторы в которых можно использовать любые не-ASCII символы.

Названия встроенных типов или имена служебных функции системной библиотеки определяются только конкретной реализацией языка, 
не являются зарезервированными ключевыми словами и при необходимости могут быть переопределены, например, для создания собственного, 
предметно-ориентированного диалекта (DSL - domain-specific language), если в этом возникнет необходимость. 
Но сама структура программы и логика выполняемого алгоритма все равно останутся понятны всем, кто знаком правилами основного синтаксиса *NewLang*.

### Расширенный синтаксис
Расширенный синтаксис — это возможность внедрения в текст программы *NewLang* вставки исходного кода непосредственно на языке реализации 
(в настоящий момент это С/С++), что позволяет использовать практически любые возможности современных средств разработки. 
Обработка расширенного синтаксиса происходит на этапе компиляции приложения.

Взаимодействие между основным и расширенным синтаксисами происходит за счет совместного использования идентификаторов, 
которое полностью прозрачно для пользователя и подчиняется единым грамматическим правилам основного синтаксиса.

#### Пример скрипта Hello world! на NewLang
    #!./nlc --eval 
    # Определение функции hello с параметром по умолчанию
    hello(str) := { 
      printf := @import('printf(format:Format, ...):Int');  # Импорт стандартной C функции
      printf('%s', $str);  # Вызов C функции с проверкой типов аргументов по строке формата
    };
    hello('Привет, мир!\n'); # Вызвать функцию со строкой аргументом

Вывод: `Привет, мир!`

### Еще немного примеров:
Любая последовательность вычислений возвращает результат выполнения последнего оператора.
Поэтому выполнение одной команды или последовательности команд всегда возвращает какой либо результат.

#### Создание переменных
    > tensor := [[1,2,3,4,5,],
               [2,3,4,5,6,],]
    [[1, 2, 3, 4, 5,], [2, 3, 4, 5, 6,],]:Char
               
    > str := '$1 string'
    $1 string

#### Арифметические операции
    > tensor * 2
    [[2, 4, 6, 8, 10,], [4, 6, 8, 10, 12,],]:Short
    
    > tensor * 20
    [[20, 40, 60, 80, 100,], [40, 60, 80, 100, 120,],]:Short
    
    > tensor * 0.5
    [[0.5, 1, 1.5, 2, 2.5,], [1, 1.5, 2, 2.5, 3,],]:Double
    
    > tensor / 2 # Результата деления — число с плавающей точкой
    [[0.5, 1, 1.5, 2, 2.5,], [1, 1.5, 2, 2.5, 3,],]:Double

    > tensor // 2 # Целочисленное деление без остатка
    [[0, 1, 1, 2, 2,], [1, 1, 2, 2, 3,],]:Char

    > tensor % 2 # Целочисленный остаток от деления
    [[1, 0, 1, 0, 1,], [0, 1, 0, 1, 0,],]:Char
    
#### Строковые операции
    > str = 'сцепеление строк' ++ ' ' ++ str
    сцепеление строк $1 string

    > str('строка как шаблон')
    сцепеление строк строка как шаблон string
    



## [Полное описание синтаксиса](https://github.com/rsashka/newlang/blob/dev/Syntax.md)


### Сборка из исходников (пока только под Linux)
#### Подготовка репозитория
- Скачать исходники
- Скачать и развернуть архив [libtorch](https://pytorch.org/) в каталоге *contrib* (PyTorch Build: Stable (1.10.*) -> Your OS: Linux -> Package: LibTorch -> Language: C++ / Java -> Compute Platform: CPU -> Download here (cxx11 ABI):
[libtorch-cxx11-abi-shared-with-deps-1.10.2+cpu.zip](https://download.pytorch.org/libtorch/cpu/libtorch-cxx11-abi-shared-with-deps-1.10.2%2Bcpu.zip))
- Активировать и скачать исходники субмодулей (`git submodule init && git submodule update`)
- В каталоге *contrib* запустить файл `build.sh` для сборки библиотеки libffi

### Собрать
- Юнит-Тесты: в каталоге *core* выполнить команду **`make CONF=UnitTest`**
- интерпретатор nlc: в каталоге *core* выполнить команду **`make CONF=Debug`**
