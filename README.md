- Подключить torch !
- перевести на torch::Tensor простые типы !
- подключить массивы !
- реализовать внутренние типы данных на основании размера сохраняемых значений !
- подключить типы данных в лексере и реализации !
- проверка типов и матричные операции с объектаим !

- База данных ключ/значение для хранения объектов (libmdbx ????????????????)

Версии:
0.1 - Выбор концепции и назначения языка. Определение его ключевых особенностей.
0.2 - Подключение библиотеки Torch и реализация системы типов. Простой интерперетор для тестирования синтаксиса и отдельных операций.

0.3 - Реализация полноценного интерпретатора для выполнения первых реальных тестовых примеров.
0.4 - Подключение базы данных и уточнение синтаксиса с учетом обратной связи.
0.5 - Реализация компилятора языка. Документирование синтаксиса и покрытие его тестами.


Большинство компиляторов промышленных языков программирования избегают сохранять анно-
тации во время выполнения: они используются при проверке типов (и, в более сложно устроенных
компиляторах, во время порождения кода), однако в скомпилированной форме программы их нет. В
сущности, перед выполнением программы преобразуются обратно в бестиповую форму. Такой стиль се-
мантики можно формализовать при помощи функции стирания, переводящей типизированные термы
в соответствующие бестиповые термы.



подсказки для автозаполнения для аргументов функций по параметрам.
buildin функции для работы с файлами (fopen, fclose и т.д.)
вывод признака объекта (с симвлом @ или $)





/*
 * Проверки типов
 * - Установка типов у литералов !
 * - Проверка соответствия типов литералов и их значений !
 * - Встроеные функции преобразования простых типов данных !
 * - Проверка типов аргументов при вызове функций !
 * - Проверка типов возвращаемых значений у функций !
 * - Проверка типов у операторов присвоения !
 * 
 * Операторы
 * - создание и инициализация тензоров
 * - использование диапазонов при инициализации значений у словарей и тензоров
 * - встроенные функции и операторы у тензоров
 * - встроеные функции преобразования составных типов данных
 * - использование диапазонов при индексации значений (срезы) 
 * - использование многоточия при индексации значений у тензоров (для словарей не имеет значения, т.к. размерность только одна)
 * 
     Передача аргументов по ссылкам 

 * - операторы возврата словаря
 * - операторы раскрытия словаря в аргументах функций
 * - операторы раскрытия словаря в операторах присвоения
 * - операторы пропуска значений при раскрытии словаря в операторах присвоения
 * 
 */

Проблемы беззнаковых чисел!
Во-первых, вычитание двух беззнаковых чисел, например 3 и 5. 3 минус 5 равно 4294967294, т.к. -2 не может быть представлено как беззнаковое число.
Во-вторых, непредвиденное поведение может возникнуть при смешивании целочисленных значений со знаком и без знака.
С++ может свободно преобразовывать числа со знаком и без знака, но не проверяет диапазон, чтобы убедиться, что вы не переполняете свой тип данных.

В C++ всё же есть несколько случаев, когда можно (или необходимо) использовать беззнаковые числа.
Во-первых, числа без знака предпочтительнее при работе с битами.
Во-вторых, использование беззнаковых чисел связаных с индексацией массивов. 
(не в текущем случае, так как индекс может быть отрицатльным и даже не числом, а диапазоном или многоточием)


 Типы данных:
- None
- Тензоры (все числовые типы)
- Строки
- Словари (dict - любые данные без наследования)


- Объекты (class - именованные данные с наследованием)

- Функции (методы)

- Ошибка ??????
- Другие ?????? (Range, ellipsis, определение типа)


- оператор конвертации типов
- бинарные данные (custom object)
- создания классов в лексере и реализация

-O3 -Wall -Wextra -Wpedantic -Wctor-dtor-privacy -Wnon-virtual-dtor -Wold-style-cast -Woverloaded-virtual -Wsign-promo -Wduplicated-branches -Wduplicated-cond -Wfloat-equal -Wshadow=compatible-local -Wcast-qual -Wconversion -Wzero-as-null-pointer-constant -Wsign-conversion -Wlogical-op -Wcast-align -Wredundant-decls



class Currency(str, Enum):
    rub = 'RUB'
    usd = 'USD'
    eur = 'EUR'
    gbp = 'GBP'
    hkd = 'HKD'
    chf = 'CHF'
    jpy = 'JPY'
    cny = 'CNY'
    try_ = 'TRY'

:Currency := ( // Enum() для контроля ограничений по именям свойств, типам данным и другим параметрам
    rub = 'RUB',
    usd = 'USD',
    eur = 'EUR',
    gbp = 'GBP',
    hkd = 'HKD',
    chf = 'CHF',
    jpy = 'JPY',
    cny = 'CNY',
    try_ = 'TRY',
    info():String := {
        "Имя - {$1}, значение - {$2}"($0.__name__, $0.__value__);
    },
);

:Currency.info():String := {
        "Имя - {$1}, значение - {$2}"($0.__name__, $0.__value__);
    };

from enum import Enum
class Students(Enum):
    IGOR = 1
    SERGEY = 2
    VASYA = 3
    def info(self):
        print("Имя - %s, значение - %s"%(self.name, self.value))
Students.IGOR.info()

Имя - IGOR, значение - 1





#pragma once
#include <experimental/coroutine>
#include <variant>

template <typename Value>
class generator {
public:
    using value_type = Value;
    using ref = value_type &;
    struct promise_type {
        using handle = std::experimental::coroutine_handle<promise_type>;
        using suspend_always = std::experimental::suspend_always;
        using suspend_never = std::experimental::suspend_never;
        std::variant<std::monostate, Value, std::exception_ptr> value;
        auto get_return_object() noexcept {
            return generator{handle::from_promise(*this)};
        }
        suspend_always initial_suspend() noexcept { return {}; }
        suspend_always final_suspend() noexcept { return {}; }
        void return_void() noexcept {
            value.template emplace<0>();
        }
        suspend_always yield_value(Value v) noexcept {
            value.template emplace<1>(std::move(v));
            return {};
        }
        void unhandled_exception() {
            value.template emplace<2>(std::current_exception());
        }
    };
    generator() noexcept = delete;
    generator(const generator &) = delete;
    generator(generator &&old) noexcept {
        std::swap(old.m_coro, m_coro);
    }
    ~generator() noexcept { if (m_coro) { m_coro.destroy();} }

    class iterator {
    public:
        [[nodiscard]] bool operator != (const iterator &second) const {
            if (m_self != nullptr) {
                return !m_self->eof();
            }
            return !second.m_self->eof();
        }
        iterator & operator++() {
            m_self->fetch();
            m_self->m_fetched = false;
            return *this;
        }
        [[nodiscard]] ref operator *() const {
            m_self->fetch();
            return m_self->value();
        }

    private:
        explicit iterator(generator *self) noexcept : m_self{self} {}
        generator *m_self;
        friend class generator;
    };
    iterator begin() noexcept { return iterator{this}; }
    iterator end() noexcept { return iterator{nullptr}; }
    ref operator ()() {
        next();
        return value();
    }

    void next() {
        m_fetched = false;
        fetch();
    }

    [[nodiscard]] bool eof() {
        fetch();
        return m_coro.promise().value.index() == 0;
    }

    ref value() {
        assert(!eof());
        if (auto err = std::get_if<2>(&m_coro.promise().value); err != nullptr) {
            std::rethrow_exception(*err);
        }
        return std::get<Value>(m_coro.promise().value);
    }

private:
    using handle = typename promise_type::handle;
    handle m_coro;
    bool m_fetched{false};

    explicit generator(handle coro) noexcept : m_coro{coro} {}

    void fetch() {
        if (!m_fetched) {
            m_coro.resume();
            m_fetched = true;
        }
    }
};

template <typename Value> concept generator_type = requires {
    typename std::decay_t<Value>::value_type;
    std::is_same_v<std::decay_t<Value>, generator<typename std::decay_t<Value>::value_type>>;
};

template <generator_type Generator, typename Predicate>
auto operator | (Generator &&source, Predicate predicate) -> std::decay_t<Generator> {
    for (auto &value: source) {
        if (predicate(value)) {
            co_yield std::move(value);
        }
    }
}

template <generator_type Generator1, generator_type Generator2,
        typename = std::enable_if_t<std::is_same_v<std::decay_t<Generator1>, std::decay_t<Generator2>>>>
auto operator + (Generator1 &&source1, Generator2 &&source2) -> std::decay_t<Generator1> {
    for (auto &value: source1) {
        co_yield std::move(value);
    }
    for (auto &value: source2) {
        co_yield std::move(value);
    }
}

template <typename Container>
auto make_generator(Container &&container) -> generator<typename std::decay_t<Container>::value_type> {
    for (auto &value: container) {
        co_yield value;
    }
}

template <generator_type Generator1, generator_type Generator2>
using pair_generator = generator<std::pair<
        typename std::decay_t<Generator1>::value_type,
        typename std::decay_t<Generator2>::value_type>>;

template <generator_type Generator1, generator_type Generator2>
auto zip(Generator1 &&source1, Generator2 &&source2) -> pair_generator<Generator1, Generator1> {
    using Value1 = typename std::decay_t<Generator1>::value_type;
    using Value2 = typename std::decay_t<Generator2>::value_type;
    while (!source1.eof() && !source2.eof()) {
        co_yield std::make_pair<Value1, Value2>(std::move(source1.value()), std::move(source2.value()));
        source1.next();
        source2.next();
    }
}

template <generator_type ...Generators>
using tuple_generator = generator<std::tuple<typename std::decay_t<Generators>::value_type...>>;

template <generator_type ...Generators>
auto zip(Generators && ...sources) -> tuple_generator<Generators...> {
    while ((!sources.eof() && ...)) {
        co_yield std::make_tuple<typename std::decay_t<Generators>::value_type...>(std::move(sources.value())...);
        (sources.next(),...);
    }
}





git clone git@github.com:rsashka/newlang.git NewLang
git clone https://github.com/rsashka/newlang.git
git submodule update --init


cd ../contrib/PDCurses/x11
./configure
make

make CONF=UnitTest


NewLanguage NEWLANG
==============
Временный репозиторий для проверки концепции языка программирования (пока без названия)

Часы NEWLANG

Грамматика:







https://habr.com/ru/company/otus/blog/575964/

Миф 3: легко ошибиться

Напротив, несмотря на то, что изучение некоторых его особенностей может занять некоторое время, 
в C++ очень сложно сделать так, чтобы ваш код сделал нежелательные вещи. Например, во многих объектно-ориентированных 
языках нет поддержки "чистых" функций, то есть функций, которые гарантированно неизменяемы. 
В C++ вы можете пометить методы класса как const, если они не изменяют его состояние. 
Затем эти методы также можно вызывать для постоянных экземпляров класса. Вот пример:

class Greeting {
public:
Greeting(std::string greeting) : greeting_(greeting) {}

std::string get_greeting() const { 
  return greeting_; 
}
std::string set_greeting(std::string new_) { 
  greeting_ = new_; 
}
private:
std::string greeting_;
};

Теперь вы можете инициализировать этот класс как константу и по-прежнему вызывать геттер. 
Когда вы попытаетесь изменить состояние класса, компилятор будет ругаться!

const Greeting g("hello");
g.get_greeting(); // returns "hello"
g.set_greeting("hi"); // does not compile

Если быть точным, эти функции не являются полностью чистыми в том смысле, что если вы неправильно 
напечатаете некоторые из ваших переменных, то возможно искажение ресурсов. Например, если у вас есть указатель 
const на не const-объект, то изменение указателя невозможно, но возможно изменение объекта, на который он указывает. 
Однако этих проблем обычно можно избежать, правильно задавая указатель (т.е. сделав его const-указателем на const-объект).

Может показаться, будто я противоречу сам себе, упоминая такой крайний случай в распространенном примере использования. 
Тем не менее, я не думаю, что это опровергает мое основное утверждение: В C++ трудно ошибиться, если вы знаете, 
чего хотите, поскольку он дает вам инструменты для выражения в коде именно того, что вам нужно. 
Хотя такие языки программирования, как Python, могут абстрагировать все это от вас, они обходятся гораздо дороже. 
Представьте, что вы идете в магазин мороженого, а вам подают только шоколад, потому что большинство людей обычно хотят 
именно его - это и есть Python. В зависимости от того, как вы на это посмотрите, конечно, в некотором смысле 
с шоколадом сложнее ошибиться, но в целом не магазин, а сам пользователь должен определять, что ему нужно.

Хорошая const-ность — это большой плюс, но есть еще несколько вещей, которые позволяет делать C++ и которые предотвращают 
появление багов в продакшене больших проектов. Он позволяет вам настраивать семантику перемещения/копирования/удаления для классов, 
которые вы разрабатываете, если вам это необходимо. Позволяет передавать данные по значению и использовать такие расширенные возможности, 
как множественное наследование. Все эти вещи делают C++ менее строгим.




введение коротко (область применения, аналоги, чем лучше), ЯП (для чего он нужен, его преимущества, основные свойства), примеры использования, etc, выводы.


Итераторы только локальные!!!!!
iter := $val??; // Итератор для всех полей у переменной $val
iter := $val??(name); // Итератор у переменной $val для полей с именем name (их может быть несколько)
iter := $val??((){}); // Итератор у переменной $val с фильтром функцией
iter := $val??((){}, arg1, $arg2); // Итератор у переменной $val с фильтром функцией в которую передаются дополнительные аргументы

find() с разными типами параметров (без параметроа, с текстовым ключем, функцией и с функцией и аргументами)

iter := @??; // Итератор для всех для всех глобальных объектов
iter := @??((){}); // Итератор для всех для всех глобальных объектов с фильтром функцией
iter := @??((){}, arg1, $arg2); // Итератор для всех для всех глобальных объектов с фильтром функцией в которую передаются дополнительные аргументы

iter := @term??; @??(term) // Итератор для всех для глобальных объектов с классом term (имя класса уникально)
iter := @term()??; // Итератор, который возвращает функция @term() (имя функции уникально и перекрывает имя класса)
iter := @term(arg1, $arg2)??; // Итератор, который возвращает функция @term()  в которую передаются дополнительные аргументы


iter := $val(name)??; // Итератор у переменной $val для полей с именем name (их может быть несколько)
iter := $val((){})??; // Итератор у переменной $val с фильтром функцией
iter := $val((){}, arg1, $arg2)??; // Итератор у переменной $val с фильтром функцией в которую передаются дополнительные аргументы



ITERATOR   ?  ?? !!  в произвольном месте
ITER_READ  !  - только итератор в цикле


iter? читать всю коллекцию с текущего места и до конца
iter?((){}) - с фильтром
iter?((){}, args, named=term()); - с фильтром и аргументами


iter - текущее значение итератора. У завершившегося итератора прочитать значение нельзя (возникнет исключение)
iter! вернуть значение и сдвинуть на следующий элемент. Если итератор уже закончился, то возникнет исключение
iter!!(123) - чтение с параметрами (по умолчанию возвращает значение в виде элемента словаря, т.е. count=1)
! и !!(0) эквивалентны, но !!(1) не вызывает исключения у завершившегося итератора, т.к. возвращяет пустой словарь

? - Читаются все даные с текущего места и до конца коллекции
?(123) - читаются указанное количество элементов с текущей позиции
?(range) - читаются элементы в указаном диапазоне относительно текущей позиции
!? или ?! - проверка итератора на завершение?  итератор возвращает один текущий объект коллекции в виде элемента словаря и переводит указатель на следующий. 
читать с начала - создать новый итератор

query( iter = find() ... ) с разными аргументами (без агументов, т.е. только итератор или число считыввемх элементов/диапазон)

iter1=0..10??;
iter2=@??(term);
[i=iter1!, term=iter2!]? <-> {$i  $term };

[i=0..10!, term=@term!]? <-> {$i  $term };

array[1,2] := [{ x,y := func()  }] Array comprehensions ???????????????????????????
list := ({ x=y := func()  }) List comprehensions ???????????????????????????



Рассмотрим простой пример. Допустим, у нас имеется лог-файл, в котором хранится статистика запросов к серверу в виде «ip bytes» через пробел, по одному хосту на
строку. Примерно так:

127.0.0.1 120
10.1.1.1 210
127.0.0.1 80
10.1.1.1 215
10.1.1.1 200
10.1.1.2 210


Нам необходимо вычислить суммарный объем траффика на каждый хост и выдать его в виде списка в поряке убывания траффика.
Программу для решения данной проблемы будет весьма недлинной :) Ее можно еще сильнее сократить, но это явно пойдет в ущерб ее читабельности.

#!/usr/bin/env python
#coding: utf8

# 1 считываем из файла строки и делим их на пары IP-адрес
raw = [x.split(" ")  for x in open("log.txt")]

# 2 заполняем словарь
rmp = {}
for ip, traffic in raw:
        if ip in rmp:
                rmp[ip] += int(traffic)
        else:
                rmp[ip] = int(traffic)

# 3 переводим в список и сортируем
lst = rmp.items()
lst.sort(key = lambda (key, val): key)
# 4 получаем результат
print "\n".join(["%s\t%d" % (host, traff) for host, traff in lst])


Разберем ее пошагово.
1. В этой строке мы читаем из файла, который открываем с помощью функции open. Функция open по-умолчанию открывает файл для чтения и возвращает файловый объект, который кроме всего прочего является итерируемым. То есть по нему можно «двигаться» с помощью цикла for, чем мы и пользуемся в нашем случае. Кроме того, с помощью метода split мы делим каждую строку на пару — адрес — траффик.
2. Для удобства, мы формируем хеш, ключами в котором являются адреса, а значениями — траффик. Если ключа еще нет, то мы его созадаем, если же есть, то мы плюсуем текущий траффик к его предыдущим «наработкам». После этого цикла мы получим хеш с суммами траффика по всем хостам.
3. К сожалению, словари в Пайтоне не сортируются. Потому нам придется перевести его в список для сортировки. Следующие две строки переводят словарь в список и осуществляют его сортировку по второму полю.
4. Вот и все что осталось — «собрать» результат, как мы уже это делали раньше.









! или ?(0) - читает из итератора один текущий объект коллекции и переводит указатель на следующий (reset выполняется только при создании). 
Невозможно распознать завершение элементов в коллекции, т.к. всегда будет возвращаться последний элемент, который может быть даже пустым значением. 
Используется в аргументах функций по умолчанию, т.к. проверка на завершение коллкции выполняется на уровне языка реализации.
!- или ?- - чтение данных итератора без перевода указателя на следующий элемент (возвращается на количество считанных данных)
!? или ?! или ?(1) - итератор возвращает один текущий объект коллекции в виде элемента словаря и переводит указатель на следующий. 
Можно расползнвать завершение элементов коллекции, так как в этом случае возвращается пустой словарь.
!! Проверка итератора на завершение коллекции. CursorMove(0)
?? Вернуть только оставшиеся элементы коллекции (reset при повторных чтениях не выполняется, а при создании эквивалентен ?)
@iterator("func", count, reset=false, move=0, @func=nullptr)

Типы данных
<пусто> - любое значение
:_ - пустое значение (не возвращает ничего)
:1 — логические значения????
:0 — целые числа (или логические значения)
:0.0 — числа с плавающей запятой
:0i0 или 0j0 — комплексные числа
:'' или "" - строка
:() - любой класс (объект)
:(name)  - класс с именем «name» ??????????????????
:[,] - ???????????????  кортеж — это структура времени компиляции. Иными словами, это некая сущность, объединяющая некоторые объекты на этапе компиляции. 
:(,) - словарь
:{} - любая функция
:(){} - только чистая функция
:0..0 - диапазон
:0? - итератор
идентификатор — тип данных указанного идентификатора (должен быть глобальной константой?)





Условный оператор "->"
(@if()) -> @then0;

(@test1() && test1()!=1) -> {@if1} 
  (@test2()) -> {@else_if2}
  (@test3() && test2()!=2) -> {@else_if3}
   -> {@else};

@test() -> @if1() : else()
@test() -> {@if1()} -> {else()}

[@test1] -> exec();
(@test2) -> {exec1();exec2();exec3()};

Оператор цикла ПОКА "(cond) <->"
[cond]?()? <-> {      }
(term == value) |-> {        }
[term == value] <-> {}
[cond(term!)?] <-> {}

Оператор цикла ДЛЯ "(iter!)? <->"
[@range(stop)]? <-> {$range  };
[i=@range(start, stop, step)!]? <-> {$i  };
[i=@range(stop)!, term=@term!]? <-> {$i  $term };
(i=@iter!; i2=iter2!;  i3=iter3!]? <-> {$i  $term };

????????????? Краткая запись оператора цикла для  "(cond!)? <->"
@range(stop)? <-> {$range  };
@range(start, stop)? <-> {$range  };
@range(start, stop, step)?  <-> {$range  };

(i=[1..5]!)? 1-2-3-4-5
(i=[1..5]!(2))? 1-3-5

(i=[1..5]!; j=[1..5]!(2))? <->  1..2..3..4..5 --- 1   +    1..2..3..4..5 --- 3     +     1..2..3..4..5 --- 5 
dict = [1,3,1];
(i=dict!)? <->  1..3..1


(){} - пустая лямбда функция (безымянная,с компиляцией во время выполнения)
(test)&&{test1, test2} - лямбда функция в синтаксисе простой функции AND
()||{} - лямбда функция в синтаксисе простой функции OR
()^^{} - лямбда функция в синтаксисе простой функции XOR

Реализация модели наследования:
~ - проверка по классу объекта, т.е. проверка имени объекта или имени базового типа (объект должен быть наследником образца)
Реализация утиной типизации:
~~ - сравнение с образцом на совместимость типов (пустой тип совместим с любым)
~~~ - сравнение с образцом на равенство типов, т.е. типы объекта должны быть идентичны образцу, включая пустой

Итератор может принимать для фильтрации объектов любую функцию, включая лямбда
@! - итератор глобальный объектов
$?
@( (obj)&&{obj~Tom} )! - итератор для объектов с именем или базовым классом Tom
@( (obj)&&{obj~human} )! - итератор для всех объектов с базовым классом human
@( (obj)||{obj~human, obj~primacy} )! - итератор для объектов с базовыми классами human или primacy
@( (obj)&&{obj~human, obj~~(sex=,parent=,)} )! - итератор для объектов с базовым классом human, у которых есть свойства sex и parent
@( (obj)&&{obj~human, obj.sex=="муж."} )! - итератор для объектов с базовым классом human, у которых свойства sex равно "муж."



Ключевое слово «...» — используется в следующих случаях. 
1. Многоточие ставится в конце аргументов функции, что означает, что функция далее может принимать произвольное количество аргументов.
2. Используется в операторах присвоения для раскрытия списков:
var1, var2, _ := ... func(); // Первый и второй элементы словаря записывается в var1 и var2, а остальные элементы возвращаемого словаря игнорируются (если они есть)
var1, var2 := ... func(); // Если функция вернула словрь с двумя элементами, то их значения записываются в var1 и var2. Если в словаре было больше двух элементов, то первый записывается в var1, а оставшиеся в var2.
var1, ..., var2 := ... func(); // Первый элемент словаря записывается в var1, а последний в var2.
3. func(... dict) - раскрытия позиционными аргументами при вызове функции.
4. func(... ...dict) - раскрытия именованными аргументами при вызове функции.

F#   выражения производят значения. Инструкции — нет.


[] - Квадратные скобки - индекс элемента
() - В круглых скобках - аргументы функций или свойства объектов

Python не отличает создание от присвоения: создание переменной – это просто присвоение ей значения
:= - оператор создания (возникнет ошибка при попытке создать существующий объект)
= - оператор присвоить значение уже существующему объекту (возникнет ошибка, если объект не создан)

tensor := [2,3,]; // [2,3,]:Int   Int[2,3]  
tensor:Int[2,name=3] := 0; // Создать тензор [ [0,0], [0,0], [0,0], ]
tensor[2,3] = 0; // Но присвоить скаляр индексу элемента
tensor[..., 0] = 999; // Присвоить 999 первому элементу во всех измерениях 

Тензор - массив чисел одного типа с произвольным количеством измерений и одинаковым размером столбцов в каждом измерении.
[,] - В квадратных скобках с обязательной конечной запятой - тензор
Тип массива определяется первым элементом или явным указанием типа через дветочие [,]:Integer.
(,) - В круглых скобках с обязательной конечной запятой - словарь (элементы произвольного типа, а достп к элементам целочисленому индексу или по имени элемента при его наличии)
["value1", "value2",] - строковый массив
(empty=, name=value, value2,) - словарь


%const := "строковая константа";
%obj := @term(); // Константа - объект
%num := 123456; // Константа - число 
%dict := (NAME1, NAME2=2, NAME3, NAME4=444, ); // Константа словарь - элементы любого типа
%array := [123, 123456,]; // Константа массив - элементы одного типа без имени
Все константы доступны в чистых функциях.
Сессионные переменные доступны в текущем модуле непосредстенно по имени.

const - доступ к константе, как к локальной переменной
%const - доступ к константе по имени, если она определена не в локальном контексте, в том числе в чистых функциях

Операторы присвоения возвращают последний результат присвоения.???????????????

Встроенные типы данных (определяются реализацией):
Типы - тензоры могут указываться с размерностью

:Char - любой байтовый тип данных (скаляр или тензор)
:Char[] - Байт скаляр
:Char[...] - Байтовый тензор любой размерности
:Char[0] - Байтовый тензор с одним измерением и произвольным количеством элементов
:Char[5] - Байтовый тензор с одним измерением и указанным количеством элементов в измерении

Остальные типы указываются только по имени, которое должно быть уникальным
:ClassName := (name:Int=0, Name2:String="", Name3, Name4=_, :String="UnNamed?"); - без базового класса

:ClassName2 := ClassName(name:Int=0, Name2:String="", Name3, Name4=_, :String="UnNamed?"); - С базовым классом ClassName
:ClassName4 :=  ClassName1(name:Int=0), ClassName2(), ClassName2(name:Int=100); - С тремя базовыми классами:ClassName4 :=  ClassName1(name:Int=0), ClassName2(), ClassName2(name:Int=100); - С тремя базовыми классами
Var:ClassName :=  ClassName2(); // Экземпляр класса
Var2:ClassName(100) :=  ClassName2(); // Экземпляр класса
Var2:ClassName :=  ClassName2(); // Экземпляр класса

Указание типа переменных используется в первую очередь в компиляторе для автоматического контроля типов (ошибок и предупрежденией),
но сами типы данных не защищены от преднамеренного измерения и это никак не контроллируется во время выполнения, т.е. 
на уровне внутреннего представления все типы реализуются одним и темже объектом.


[]:Char; - TENSOR -  Одно число (скаляр) или массив чисел <b>одного типа</b> с произвольным количеством измерений и одинаковым размером столбцов в каждом измерении с доступом к элементам по <b>целочисленному индексу</b>.
[1]:Int; - Один элемент в одном измерении
типизированный ТИП времени компиляции

[,] кортеж —  Набор ДАННЫЕ <b>произвольного типа</b> с доступ к элементам по <b>целочисленному индексу</b> или по <b>имени элемента</b> при его наличии.
            это структура времени компиляции (известная компилятору и анализиуремая во время компиляции). Иными словами, это некая сущность, объединяющая некоторые объекты на этапе компиляции.  Набор данных <b>произвольного типа</b> с доступ к элементам по <b>целочисленному индексу</b> или по <b>имени элемента</b> при его наличии.
(,) словарь ДАННЫЕ структура времени исполнения (НЕ анализиуремая во время компиляции) - Набор данных <b>произвольного типа</b> с доступ к элементам по <b>целочисленному индексу</b> или по <b>имени элемента</b> при его наличии.
():Name - класс, тоже ТИП с возможными значениями по умолчанию.
(условно)типизированный времени исполнения

<> ?????????????? перечисление - Константный набор УНИКАЛЬНЫХ именованных чисел времени компиляции (известная компилятору и анализиуремая во время компиляции)
obj[] = value; // Добвить новый элемент к словарю или тензору
obj[].name = value; // Добавить новые элемент с именем "name" к коллекции (допускаются дубли имен элементов)
obj[1] = value; // Присвоить новое значение элементу с индексом 1 (индекс элементов от единицы)
obj[pos] := value; // Присвоить новое значение элементу с индексом 1, если размер массива pos-1, то увеличить размер массива на единицу
obj.name = value; // Присвоить новое значение элементу с именем "name", если элеменат с таким именем нет, возникнет ошибка
obj.name := value; // Присвоить новое значение элементу с именем "name", если элеменат с таким именем нет, то создать его

Разрешено использование не-ASCII символов в идентификаторах, в том числе любых национальных символов, 
определённых в спецификации Unicode UAX 31, но кроме символов emoji и знаков, не ассоциируемых с символами. 
Кроме того, при использовании разных, но похожих по начертанию символов, компилятор выведет предупреждение. 


Cуществует три основных типа поиска имени в С/С++, каждый со своим собственным набором правил. https://habr.com/ru/post/550442/
    Поиск имени по методам (Member name lookup) происходит, когда имя находится справа от токена . или ->, как в foo->bar. Этот тип поиска используется для поиска методов класса.
    Поиск квалифицированного имени (Qualified name lookup) происходит, когда имя содержит токен ::, например, std::sort. Этот тип имени является явным для компилятора. Часть справа от токена :: ищется только в области видимости, обозначенной в левой части.
    Поиск неквалифицированных имён (Unqualified name lookup) не является ни тем, ни другим. Когда компилятор видит неквалифицированное имя, например blast, он ищет совпадающие декларации функций в множестве различных областей в зависимости от контекста. Существует подробный набор правил, который точно определяет, где должен искать компилятор.


Все функции делаятся на обычные и чистые (pure)
Внутри чистых функций есть доступ только к локальным переменным и другим чистым функциям.
Внутри обычных функци доступны любые функции и данные, т.е. чистую функцию можно вызать из обычной, а обычную из чистой нельзя.
Разделение объектов на локальные и глобальные необходимо для работы с разными типами функций (с обычными и чистыми).
Локальные объекты начинаются на символ "$" и время его жизни до конца текущей области видимости.
Глобальные объекты начинаются на символ "@" и время его жизни не зависимо от текущей области видимости.
Обычное имя без квалификатора "$" или "@" - неквалифицированное имя объекта, поиск которого происходит сперва в локальной области видимости,
а потом в глобальной области видимости (при её доступности).

Локальный контекст "Context", это способ переопределить глобальные объекты при обработке локальных данных.
Локальный контекст доступен во всех видах функций (и в чистых, и в обычных), и через него происходит обращение (вызов) функций, 
т.к. в нем сордержатся ссылки (weak_ptr) при создании локальных объектов.



# - константа времени выполнения
% - константа времени компиляции
() имя/вызов функции (метода объекта)


func():Type := @import("module_name"=None, "func_name"=None, lazzy=false);
obj:Type := @import("module_name"=None, "obj_name"=None, lazzy=false);


func() := @function("module_name"=None, "func_name"=None, lazzy=false);
obj := @variable("module_name"=None, "obj_name"=None, lazzy=false);

obj:Type := %local(local_c++_name);
obj:Type := @import("module_name"=None, "obj_name"=None, lazzy=false);
%export(obj, "as_name"=None);


// Импорт целых классов !!!!!
Будет работать только при компиляции !!!!!!!!!!!!!!!!!
import_class := cpp_constructor(){
    // У всех тип неизменяемый !!!!
    field1:Int := @property(prototype="field1_int:Int", name=None); // Член класса
    field2:StrChar := @property(prototype="field2_str:StrChar",name="field2_str"); // Член класса
    field_str(str:StrChar):StrChar := @property(prototype="field_str(str:StrChar):StrChar"); // Член класса

    __get__(name):string := {

    }
    __set__(name:string, value) := {

    }
    __unset__(prop) := {

    }
    __del__(prop) := {

    }
};


Неравенства можно объединять в цепочки:
y = 5
y += 2
4 <= y < 8
Out: true

Комплексные числа
Рациональные числа ?? используя "//" и соответствующими функциями:

    num(x) — числитель,
    den(x) — знаменатель,
    float(x) — преобразует к десятичной дроби


x = 4//6+5//7
Out: 29//21
float(x)
Out: 1.380952380952381

56\55*55    1/\2 1\/2/ № : ` ~ ! * & ^ % $ @ _ /  \_   1_33\255_33  1_33/255_33  1_33//255_33

122+15j
122-15j

.&.
.|.
.^.
.!.


:= создание локальной переменной
= присвить новое значение существующему объекту/переменной


@[].name = var; регистрация локального объекта как глобального без создания локальной переменной
@[].name = var(); регистрация КОПИИ объекта как глобального без создания локальной переменной

Идентификатором объектов является его имя, причем у сессионных и глобальных объектов оно присваивается автоматически даже для переменных литералов.
Имена локальных объектов перекрывают сессионные и глобальные, а сессионный объкт перекрывает глобальный.
Дубли локальных объектов не допускаются, т.к. имена локальных переменных должны быть уникальные на уровне языка реализации.
Дубли сессионных объектов для текущей сессии не допускаются, но можно перекрывать сессионные объекты более высокого уровня.
Дубли глобальных объектов допускаются без ограничений, а при создании дубля выводится предупреждение.

При наличии переменных с одним именем, но разным временем жизни, приоритет доступпа будет следующим.
обращение по имени объекта - доступ только к локальному объекту (разрешение имени происходит во время компиляции) или будет ошибка если объект отсутствует.
обращение как к сессионному обекту (префикс $) - если есть локальный объект, вернется локальный, иначе вернется сессионный или будет ошибка если объект отсутствует.
обращение как к глобальному обекту (префикс @) - если есть локальный, вернется локальный, иначе вернется сессионный, иначе вернется глобальный или будет ошибка если объект отсутствует.

Можно всегда указывать глобальный идентификатор объекта, то доступ будет в зависимости от наличия локальных или сессионных переменных/объектов.

$.obj прямое обращения к сессионному объекту при наличии локального
@.obj прямое обращения к глобальному объекту при наличии локального или сессионного

Имя функции с именем объекта перекрыват прямое создание копии объекта:
clone_obj := obj(); Копия объекта
clone_2 := clone_obj(); Копия клона объекта, но так как функции создаются при компиляции модуля, то тут уже будет вызов функции
clone_obj() := {}; создание функции с именем объекта
clone_3 := clone_obj(); Вызов функции, вместо создания копия клона объекта



field_name := "name";
obj.$field_name или obj.@field_name - в реальности будет обращение к полю  obj.name, т.к. имена перекрываются локальной переменной 

#! - однострочный комментарий в начале файла (шебанг для совместимость с bash)
$0 - Текущий объект
$1,$2, $arg - номера и имена аргументов
$[   ] - коллекция сессионных объектов
$* - строковое представление аргументов
$# - количество аргументов
(var=1..$#)? <-> $[$var] перебор переданных аргументов  `${$[$var]}` преобразование аргумента в строку

##  result;
###  exception;
^^
&&
[<
[>
<]
|
\\
//
!!
`
``
=>
->
<->

[метка>; # Переход на метку
[>; # Аналог break (выход из цикла)

<метка];
<]; # Аналог continue (на начало цикла)

<ошибка>; # Прерывание выполнения с сообщение об ошибке
<>;

Инкремент и декремент убрать ??????
Обоснование - нет реализаций для сторок и тензоров + расширяется семантика языка.
++ отдельный оператор конкатенации строк

--; оператор выхода ?????
-- ошибка --;

строк ++ строка;
// - целочисленное деление
** - возведение в степень

Битовые операторы (как в Haskel)????
.|.  OR
.&.  AND
.^.  XOR
.~.  NOT
.<.  SHL
.>.  SHR

|->
&->

$var - локальный объект (владеет). Не добавляется в список сессионных объектов. 
    Прямой доступ в программных вставках по префиксу.
var - локальный объект (владеет) + добавляется в список сессионных объектов. 
    Реализуется как список слабых ссылок (weak_ptr) на локальные объекты с самого верхнего уровня вложенности.
    Нет прямого доступа в программных вставках, т.к. требуется выполнять поиск в списке,
    но объект можно получить через вызов глобальной функции @eval("var");
@var - глобальный объект (владеет).
    Прямой доступ в программных вставках по префиксу.

Происходит поиск сперва в локальных, затем в глобальных объектах
$var1 := 123; # Доступно в программной вставке и в списке сессионных объектов
var2 := 345;

func1(arg1) := { $arg1 и $1 аргументы первой функции 
    $var1_1 := 1;
    var1_2 := 11;
    %{  $var1_1; // Прямой доступ %}
    %{  @eval("var1_2"); // Для var1_2 нет прямого доступа %}

    func2(arg2) := { $arg2 и $1 аргументы второй функции 
        # Нет доступа к локальному объекту $var1_1
        var1_2(); # Получение объекта из контекста (для обычных функций) и запрещено для чистых
        

        --;
        <"Ошибка">;
        <error>;
    }
}



Префиксы $ и @ требуется в коде С++ для реализации прозрачного доступа к объектам между разными синтаксисами.



@@ глобальный класс
@$ сессионный класс (модуля)
$$ возврат (return) ??????????????????????
%% возврат (return)
## ошибка (except)

@@class_name := (prop=), @base1, @base2(arg1, arg2) {

filed_new := value; // Новое поле
filed_old = override; // Переопределение существующего поля/функции одного из базовых классов

::base1.field_2 ????????????????????????

_name - защищенное имя
__name - скрытое (приватное) имя
__name__ - системное имя (для чтения и не входит в список полей)

name_ - in-place функция (изменяет сам объект)
name - const имя / функции (не изменяет объект)

методы, которые определяются внутри класса, могут проверять имена полей объектов во время компиляции приложения ($0->field).
Методы, котрые определены вне тела класса, не могут проверять имена полей класса во время компиляции.
И первые, и вторые можно вызывать для конкретного объекта, так и без объекта (как статические функции), 
а доступ к полям объекта ($0->field) будет определяется способом вызова,
и при вызове метода без объекта, нулевой метода аргумент будет пустым.

$field_call = {}; // Вызывается при преобразовании в тензор, обязано иметь аругменты по умолчанию и может быть только чистой функцией???
@field_not_call = {}; // Не вызывается при преобразовании в тензор без ограничений

};

!!!!! требует обязательной инициализации значений переменных перед использованием, 
применяет концепцию неизменяемости (immutable) ссылок и переменных по умолчанию !!!!!!!!!

Соглашение о именовании в PyTorch гласит, что любая функция вида xxx возвращает новый тензор, т.е. является immutable функцией. 
В противоположность ей функция вида xxx_ изменяет изначальный тензор, т.е. является mutable функцией. 
Последние ещё носят название inplace функций.


Преобразование расширенных объектов (не тензоров) в тензорры

Последовательно элемент за элементом по умолчанию в одномерный тензор.
При приобразовании в многомерный тензор, остаток (хвост) заполняется нулями, 
если данных для заполнения измеренения полность не достаточно.

Из этого следует, что:
- последовательность полей при преобразовании важна (имеет значение)!
- при расширении класса, наследник совместим с родителем только общими (базовыми) полями.
- поля-функции (только чистые????) должны иметь аргументы по умолчанию, вызываются перед преобразованием, а в тензор преобразуются их результат???
- Преобразование в тензор должно происходить внути класса, т.к. за именно он отвечает за представление обработываемых данных 
(например конвертирует в двухмернуя матрицу для сверточной сети).
- итоговый тип тензора так же устанавливается внути класса




::class_name::field_2 := data; // Определение поля класса (для всех объектов) вне тела класса (рантайм)
class.field_2 := data; // Определение нового поля конреного объекта (рантайм)
class_name::base1.field_2 ????????????????????????

::class_name::func_new := call(); // Определение функции класса (для всех объектов) вне тела класса (рантайм)
class.func_obj() := {}; // Определение новой функции конкретного объекта (рантайм)





Правило №1: не бойтесь запускать продукт без машинного обучения.

Машинное обучение — это здорово, но для него требуются данные. 
Теоретически, можно взять данные из другой задачи и подстроить модель под новый продукт, но она, скорее всего, 
не справится с базовыми эвристиками. Если вы предполагаете, что машинное обучение придаст вам рост на 100%, то эвристика даст вам 50%.


Множество практиков машинного обучения, с которыми я проводил интервью в рамках проекта Applying ML, в ответ на этот вопрос тоже 
дают похожие ответы: «Представьте, что вам дали новую незнакомую задачу, которую нужно решить при помощи машинного обучения. Как вы подойдёте к её решению?»

«Для начала я приложу серьёзные усилия к тому, чтобы проверить, можно ли решить её без машинного обучения. 
Я всегда стремлюсь пробовать менее гламурные, простые вещи, прежде чем переходить к более сложным решениям». — Вики Бойкис, инженер ML в Tumblr

«Я думаю, что сначала важно выполнить задачу без ML. Решить задачу вручную или при помощи эвристик. 
Это заставит вас глубоко освоить задачу и данные, что является самым важным первым шагом. 
Более того, стоит получить точку отсчёта без ML, чтобы честно сравнивать показатели». — Хамел Хуссейн, ведущий инженер ML в Github

«Сначала попробуйте решить задачу без машинного обучения. Этот совет дают все, потому что он хорош. 
Можно написать несколько правил или эвристик if/else, чтобы принимать простые решения и действовать на их основе». — Адам Лаиакано, ведущий инженер платформы ML в Spotify



Тогда с чего начинать?

Вне зависимости от того, используете ли вы простые правила или глубокое обучение, всегда помогает достаточный уровень понимания данных. 
Поэтому возьмите выборку данных, чтобы собрать статистику и визуализировать её! 
(Примечание: в основном это относится к табличным данным. По другим данным, как то изображения, текст, звук и т.д., собирать статистику может быть сложнее.)

Простые корреляции помогают в выявлении связей между каждым признаком и целевой переменной. 
Затем можно выбрать подмножество признаков с самыми сильными связями, чтобы их визуализировать. 
Это не только помогает с пониманием данных и нашей задачи (а значит, и с более эффективным использованием машинного обучения), 
но и позволяет лучше освоить контекст предметной области бизнеса. 

Однако стоит заметить, что корреляции и собранная статистика могут вводить в заблуждения — иногда оказывается, 
что переменные, имеющие сильные связи, обладают нулевой корреляцией (подробнее об этом ниже).


Я выяснил, что если какая-то из переменных является категорийной, то хорошо подходят диаграммы типа «ящик с усами». 
Допустим, вы пытаетесь спрогнозировать срок жизни собаки — насколько важен её размер для этого параметра?




Когда же нужно использовать машинное обучение?

После того, как у вас появится точка отсчёта без ML с достаточно хорошими показателями, и объём усилий по 
поддержке и совершенствованию этой точки отсчёта перевешивает объём усилий по созданию и развёртыванию системы на основе ML. 
Сложно конкретно указать, когда это случается, но когда становится невозможно изменять ваши 195 созданных вручную правил без того, 
чтобы что-то не сломалось, то стоит задуматься о машинном обучении. Вот правило №3 из Правил ML компании Google.

Правило №3: выбирайте машинное обучение вместо сложной эвристики.

Простая эвристика может позволить выпустить продукт. Сложную эвристику невозможно поддерживать. 
После того, как у вас накопились данные и появилось базовое понимание того, что вы пытаетесь достичь, переходите к машинному обучению… 
и вы обнаружите, что модель машинного обучения проще обновлять и поддерживать.

Наличие надёжных конвейеров обработки данных и высококачественной разметки данных тоже дают понять, что вы готовы к машинному обучению. 
Но прежде чем это произойдёт, имеющиеся у вас данные могут быть недостаточно хороши для машинного обучения. 
Допустим, вам нужно снизить уровень мошенничества на вашей платформе, но вы даже не знаете, как выглядит мошенническое поведение, 
не говоря уже об отсутствии меток.







Метки для break и contunue

Как в Java - операторы могут передавать управление на метки. 
Такие переходы не могут образовывать цикл, и не могут вести внутрь управляющих структур; 
допускаются только выходы наружу из вложенных блоков.

Блок else для циклов
Как в Python - управление передается в блок else, если внутри цикла не сработал break 
(т.е. выход из цикла был естественный, по условию самого цикла).


Постфиксные функции
Альтернативный синтаксис вызова, при котором аргумент указывается перед именем функции. 
Обычно используется для преобразования базовых литералов в пользовательские литералы, 
где ?` обозначает имя постфиксной функции, а ` обозначает вызов постфиксной функции. 
Например, следующий код преобразует литералы, представляющие физические величины, в другие единицы измерения.

double ?`ft(double f) { return f / 3.28084; }
printf("100 feet == %f meters\n", 100`ft);

Постфиксные функции могут быть и с несколькими аргументами, в этом случае постфикс применяется к кортежу [ char, int, double ].









a[start:stop]  # items start through stop-1
a[start:]      # items start through the rest of the array
a[:stop]       # items from the beginning through stop-1
a[:]           # a copy of the whole array

There is also the step value, which can be used with any of the above:
a[start:stop:step] # start through not past stop, by step

The key point to remember is that the :stop value represents the first value that is not in the selected slice. 
So, the difference between stop and start is the number of elements selected (if step is 1, the default).
The other feature is that start or stop may be a negative number, which means it counts from the end of the array instead of the beginning. So:
a[-1]    # last item in the array
a[-2:]   # last two items in the array
a[:-2]   # everything except the last two items
Similarly, step may be a negative number:
a[::-1]    # all items in the array, reversed
a[1::-1]   # the first two items, reversed
a[:-3:-1]  # the last two items, reversed
a[-3::-1]  # everything except the last two items, reversed
Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for a[:-2]
and a
only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.
Relation to slice() object 
The slicing operator [] is actually being used in the above code with a slice() object using the :
notation (which is only valid within []), i.e.:
a[start:stop:step] is equivalent to: 
a[slice(start, stop, step)]

Slice objects also behave slightly differently depending on the number of arguments, similarly to range(), i.e. both slice(stop)
and slice(start, stop[, step]) are supported. To skip specifying a given argument, one might use None, so that e.g. 
a[start:] is equivalent to a[slice(start, None)] or a[::-1] is equivalent to a[slice(None, None, -1)].
While the :-based notation is very helpful for simple slicing, the explicit use of slice() objects simplifies the programmatic generation of slicing.




Верно, проблема ссылок в их неявности. 
В C#, например, о намерении передать аргумент по ссылке, допускающей изменение объекта, 
надо указывать не только в заголовке функции, но и каждый раз при вызове функции.

При определении метода, который возвращает ссылку, следует учитывать, что такой метод естественно не может иметь тип void. 
Кроме того, такой метод не может возвращать:
    Значение null
    Константу
    Значение перечисления enum
    Свойство класса или структуры
    Поле для чтения (которое имеет модификатор read-only)


По умолчанию, в случае, когда не предпринимается никаких соответствующих исправительных мер, условия переполнения (overflow) 
и потери значимости (underflow) происходят без выдачи ошибки. Обрабатывать условия переполнения и потери значимости 
в приложении можно двумя способами. 
В C# предусмотрено ключевое слово checked. Если оператор (или блок операторов) заключен в контекст checked, 
компилятор C# генерирует дополнительные CIL-инструкции, обеспечивающие проверку на предмет условий переполнения, 
которые могут возникать в результате сложения, умножения, вычитания или деления двух числовых типов данных.

В случае возникновения условия переполнения во время выполнения будет генерироваться исключение System.OverflowException. 



use(module) #= @@(module); // #use(module)
return(obj) #= $$(obj); // #return(obj)
error(message="Error") #= ##(message); // #error
size(obj) #= $#(obj); // #size(obj)
count(obj) #= $#(obj); // #count(obj)
tostr(obj) #= $*(obj); // #tostr(obj)


Переход (аналог goto) работает только в локальном контексте, т.к. метками для него служат определения локальных переменных
Ошибка (аналог исключения) прерывает выполнение последовательности команд и возвраащет отписание ошибки.
Любая операция с ошибкой вызывает повторение ошибки, кроме операций вывода описания и сравнения типа (~ ~~ ~~~).
Ошибки ловятся только оператором eval и call при вызове обычных функций ????????????????????????????????????????????????
Обычная функция может вернуть или результат или ошибку, а чистая функция может вернуть только результат, т.к. в сулчае ошибки, 
происходит прерывание выполнения и возврат из eval или callобычной функции. ???????????????????????????????????????????
Операторы или другие способы поймать и обработать ошибочную ситуацию не предусмотрены.



https://habr.com/ru/post/570642/
Более того, исключения имеют семантику goto, что означает, что они позволяют легко переходить из любой 
точки вашей программы в блок catch. На самом деле, исключения работают еще хуже, потому что оператор 
goto не позволяет выходить за пределы определенного метода, тогда как с исключениями вы можете легко 
пересекать несколько уровней в своей базе кода. "Избегать исключения для управления потоком программы. "

Существует некий предел сложности, с которой мы можем справиться за раз. 
Если кодовая база проекта превышает этот предел, становится действительно трудно, а в какой-то момент 
даже невозможно что-либо изменить в программном обеспечении без каких-либо неожиданных побочных эффектов.

Применение принципов функционального программирования помогает снизить сложность кода. 
Оказывается, программирование с использованием математических функций значительно упрощает нашу работу. 
Благодаря двум характеристикам, которыми они обладают - честности сигнатуры метода и ссылочной прозрачности - мы можем 
гораздо проще понимать и рассуждать о таком коде.


---------------- $$ - Возвращаемый результат
@term[Tom]:=@term();
@[  ] - коллекция глобальных объектов
& - ссылка
%{ %} - исполняемый код на языке реализации


let name: string = "bob";
name = 'smith';

Вы также можете использовать строки с шаблонами, которые могут быть многострочными и иметь встроенные выражения. 
Эти строки окружаются обратными апострофами или кавычками(`) и встроенные выражения обозначаются как ${ expr }.

let name: string = `Gene`;
let age: number = 37;
let sentence: string = `Hello, my name is ${ name }.

I'll be ${ age + 1 } years old next month.`

Эквивалент этого объявления sentence:

let sentence: string = "Hello, my name is " + name + ".\n\n" +
    "I'll be " + (age + 1) + " years old next month."




Перечисление т.е. "enum" может быть реализовано как с помощью массива, так и с помощью словаря.
В обоих случаях элемент перечисления определяется через точку "emun.name" и разные реализации между собой можно смешивать.
В случае массива, значением элемента статовится его целочисленный индекс, соответственно и дублей значений отсутствуют, но сами имена элементов могу повторяться.
При определении перечисления с помощью словаря, имена элементов уникальны, но значения элементов могут быть заданы произвольно, в том числе с указанием дубликатов значений элементов.
При отсутствии заданного значения, численым значением элемента становится его индекс, как у элемента множества на основе массива.
Элемент словаря, у котрого отсутствует имя, не может быть элементом перечисления.
Если определить перечисления как aenum := [name0, name1, name2,] и denum := (name0=0, name1=0, name2=1,), 
то выражения aenum.name0 == denum.name0 и aenum.name0 == denum.name1 будут истинными.




Prolog:
male("Tom").
male("Tim").
male("Jake").
female("Janna").
parent("Tom","Jake").
parent("Janna","Jake").
parent("Tom","Tim").

brother(X,Y):- parent(Z,X),parent(Z,Y),male(X),male(Y),X\=Y.
Вывод: (Jake, Tim) (Tim, Jake) 

Тот же самый пример:
human:=@term(sex=,parent=); // Значений по умолчанию нет, но сами поля с указанными именами присутствуют в объекте
Tom:=@human(male);
Janna:=@human(female);
Jake:=@human(male, (Tom, Janna,));
Tim:=@human(parent=(Tom,), sex=male);

human::brother(test=human!) &&= $0!=$test, $0.sex==male, @intersec($0.parent, $test.parent);

Примеры выполнения команды:
human.brother?

Вывод: [Tim.brother(Jake), Jake.brother(Tim),]





#[human]:=@term(sex=,parent=[]); // Значений по умолчанию нет, но сами поля с указанными именами присутствуют в объекте
@[]:=(Tom, @human(male),); // Так неполуичится различить эелемент в вивде коллекции
@[Tom]:=@human(male);
@term[Janna]:=@human(female);
@term[Jake]:=@human(male, [Tom, Janna]);
@term[Tim]:=@human(parent=[Tom], sex=male);

human::brother(test) &&= $0!=$test, $0.sex==male, @intersec($0.parent, $test.parent);

Примеры выполнения команды:
human.brother(@human!)?
