# Итераторы

Итератор в С++ — это объект, который может перебирать элементы в контейнере и предоставлять доступ к отдельным элементам. Все контейнеры стандартной библиотеки С++ предоставляют итераторы, чтобы алгоритмы могли получить доступ к их элементам стандартным способом, независимо от типа контейнера, в котором сохранены элементы. что итератор C++ это интерфес у которого перегружены некоторые операции, такие как инкремент, обращение по ссылки и пр., но сам итератор концептуяально является указателем и для контроля завершения итератора требуется сравнивать текущий элемент в последей позицией в контейнере (т.е. для сравнения текущего элемента с end()).

Итераторы в NewLang и итераторы в C++ очень сильно отличаются.

  
Требуется разделять конейнеры с данными и итераторы по данным.
В С++ контейнеры данных предоставялют итераторы, для работы с которыми требуются сами контейнеры непосредствено.
Это удобно для использования в рукописном коде, но сложно контроллировать в генерируемом исходнике, 
     * т.к. требуется использовать и итертор и сам контейнер с данными (для сравнения текущего элемента с end()).
     * 
     * Итератор - отдельный объект, которому для создания требуется контейнер с данными.
     * Итератор реализует два интерфейса перебора данных:
     * 1. - первый интерфейс итератора как в С++ 
     * 2. - второй интерфейс для использования в генерируемом коде  с логикой NewLang
     * 
     * template Iterator - Обертка над классическим С++ итератором с добавлением возможности отбора
     * элементов по имени поля или с помощь функции обратного вызова для пользовательской фильтрации.
     * 
     * Программынй интерфейс итераторов для NewLang следующий:
     * 
     * ObjPtr IteratorMake(const std::string filter) - создать итератор с возможностью фильтрации по имени поля (данные на начало)
     * ObjPtr IteratorMake(Obj * args) - создать итератор с фильтрации с помощью пользовательской функции (данные на начало)
     * ObjPtr IteratorReset() - Сбросить итератор на начало данных (возвращает сам итератор)
     * ObjPtr IteratorData() - прочитать текущий элемент без смещения указателя. Если данных нет возвращается "конец итератора"
     * ObjPtr IteratorNext(int64_t count)- прочитать заданное кол-во элементов и переместить итератор на следующий элемент. 
     * При не нулевом кол-ве, данные возвращаются как элементы словаря. Если указан кол-во элеметов 0 - возвращается текущий элемент.
     * 
     * Реализаиця итераторов NewLang с помощью данного интерфейса:
     *
     * Создание итератора
     * ?, ?("Фильтр"), ?(func), ?(func, args...)    - IteratorMake
     * 
     * Перебор элементов итератора
     * !, !(0), !(3), !(-3)
     * 
     * dict! и dict!(0) <НЕ> эквивалентны, т.к. по разному обработывают конец данных
     * dict! -> 1,  dict! -> 2, dict! -> 3, dict! -> 4, dict! -> 5, dict! -> исключение "конец итератора"
     * dict!(0) -> 1,  dict!(0) -> 2, ... dict!(0) -> 5, dict!(0) -> :IteratorEnd (может :Empty  - пустое значение ?? )
     * dict!(1) -> (1,),  dict!(1) -> (2,), ... dict!(1) -> (5,), dict!(1) -> (,)
     * 
     * Различия отрицательного размера возвращаемого словаря для итератора 
     * (Для отрцетельного размера всегда зозвращается словарь указанного размера)
     * dict!(-1) -> (1,),  ...  dict!(-1) -> (5,),  dict!(-1) -> (:IteratorEnd,),  
     * dict!(1) -> (1,),  ...  dict!(1) -> (5,),  dict!(1) -> (,),  
     * dict!(-3) -> (1, 2, 3,),  dict!(-3) -> (4, 5, :IteratorEnd,)
     * dict!(3) -> (1, 2, 3,), dict!(3) -> (4, 5,)
     * 
     * Операторы ?! и !? эквивалентны и возвращают текущие данные без перемещения указателя итератора (IteratorData) и не принимают аргументов.
     * Остальные итераторы можно вызвать либо без скобок, либо с аргментами в скобрках. Вызов без аргументов зарпрешщен 
     * (чтобы не пересекаться с логикой копирования объектов и не делать для итераторов аругменты по умолчанию)
     * 
     * Оператор ?? создает итератор и сразу его выполняет, возвращая все значения 
     * в виде элементов словаря, т.е. аналог последовательности ?(LINQ); !(:Int64.__max__);
     * 
     * Оператор !! без аргументов - сбрасывает итератор в начальное состояние (IteratorReset),
     * Обператор !! с аргументами выполняется как ! с аругментами, но с начла коллекции.



```
dict := (1,2,3,); # Словарь с тремя элемнтами
iter := dict?; # Итератор по всем элементам словаря
iter!;  # Вернется 1
iter!;  # Вернется 2
iter!;  # Вернется 3
iter!;  # Произойдет исключение "конец итератора"

iter?!; # Произойдет исключение "конец итератора"

  ```

 
     * Перебор элементов итератора
     * !, !(0), !(3), !(-3)
     * 
     * dict! и dict!(0) <НЕ> эквивалентны, т.к. по разному обработывают конец данных
     * dict! -> 1,  dict! -> 2, dict! -> 3, dict! -> 4, dict! -> 5, dict! -> исключение "конец итератора"
     * dict!(0) -> 1,  dict!(0) -> 2, ... dict!(0) -> 5, dict!(0) -> :IteratorEnd (может :Empty  - пустое значение ?? )
     * dict!(1) -> (1,),  dict!(1) -> (2,), ... dict!(1) -> (5,), dict!(1) -> (,)
     * 
     * Различия отрицательного размера возвращаемого словаря для итератора 
     * (Для отрцетельного размера всегда зозвращается словарь указанного размера)
     * dict!(-1) -> (1,),  ...  dict!(-1) -> (5,),  dict!(-1) -> (:IteratorEnd,),  
     * dict!(1) -> (1,),  ...  dict!(1) -> (5,),  dict!(1) -> (,),  
     * dict!(-3) -> (1, 2, 3,),  dict!(-3) -> (4, 5, :IteratorEnd,)
     * dict!(3) -> (1, 2, 3,), dict!(3) -> (4, 5,)
     * 
     * Операторы ?! и !? эквивалентны и возвращают текущие данные без перемещения указателя итератора (IteratorData) и не принимают аргументов.
     * Остальные итераторы можно вызвать либо без скобок, либо с аргментами в скобрках. Вызов без аргументов зарпрешщен 
     * (чтобы не пересекаться с логикой копирования объектов и не делать для итераторов аругменты по умолчанию)
     * 
     * Оператор ?? создает итератор и сразу его выполняет, возвращая все значения 
     * в виде элементов словаря, т.е. аналог последовательности ?(LINQ); !(:Int64.__max__);
     * 
     * Оператор !! без аргументов - сбрасывает итератор в начальное состояние (IteratorReset),
     * Обператор !! с аргументами выполняется как ! с аругментами, но с начла коллекции.
     * 
     * [ ] - оператор приведения данных в логический тип. Испольуется в алгоритмических конструкциях (проверка условий и циклы)
     * Правила преобразования в логический тип:
     * Словарь или класс - нет элементов - false, есть элементы - true
     * Число - ноль или нулевой тензо - false, иначе true
     * Строка - пустая строка false, иначе true
     * Итератор - конец данных false, иначе true
     * :IteratorEnd (:Empty ?) - всегда false
     * None - true (Это объекст со значением пусто)
     * Empty - false (Не инициализированный объект)
     * 
     * 
     * Логика обработки ссылок
     * term1 :=  term; # Объект term1 - копия term.
     * term2 :=  &term; # Объект term2 - ссылка на term (одни и те же данные, т.е. shared_ptr ссылаются на один и тот же объект)
     * &term3 :=  term; # Создать объект term3 и вернуть ссылку на него (сахар для term3 :=  term; &term3;)
     * 
     * 
     * copy(arg) :=  {}; # Обычная функция принимает любой аргумент как <КОПИЮ> значения
     * copy(term1); # ОК - передается <КОПИЯ> term1
     * copy(term2); # ОК - передается <КОПИЯ> term2
     * copy(&term1); # ОК - передается ссылка на term1 (На самом деле копия ссылки, которая указывает на те же данные)
     * copy(&term2); # ОК- передается ссылка на term2 (На самом деле копия ссылки, которая указывает на те же данные)
     * 
     * ptr(&arg) :=  {}; # Функция, которая принимает только аргумент - <ссылку>
     * ptr(term1); # Ошибка при компиляции - нужно передавать ссылку !!!!!!!!
     * ptr(&term1); # ОК
     * ptr(&term2); # ОК
     * ptr(term2); # Ошибка при компиляции - нужно передавать ссылку, несмотря на то что term2 УЖЕ содержит ссылку !!!!!!!!





Итераторы в NewLang и итераторы в C++ очень сильно отличаются.

  
Требуется разделять конейнеры с данными и итераторы по данным.
В С++ контейнеры данных предоставялют итераторы, для работы с которыми требуются сами контейнеры непосредствено.
Это удобно для использования в рукописном коде, но сложно контроллировать в генерируемом исходнике, 
     * т.к. требуется использовать и итертор и сам контейнер с данными (для сравнения текущего элемента с end()).
     * 
     * Итератор - отдельный объект, которому для создания требуется контейнер с данными.
     * Итератор реализует два интерфейса перебора данных:
     * 1. - первый интерфейс итератора как в С++ 
     * 2. - второй интерфейс для использования в генерируемом коде  с логикой NewLang
     * 
     * template Iterator - Обертка над классическим С++ итератором с добавлением возможности отбора
     * элементов по имени поля или с помощь функции обратного вызова для пользовательской фильтрации.
     * 
     * Программынй интерфейс итераторов для NewLang следующий:
     * 
     * ObjPtr IteratorMake(const std::string filter) - создать итератор с возможностью фильтрации по имени поля (данные на начало)
     * ObjPtr IteratorMake(Obj * args) - создать итератор с фильтрации с помощью пользовательской функции (данные на начало)
     * ObjPtr IteratorReset() - Сбросить итератор на начало данных (возвращает сам итератор)
     * ObjPtr IteratorData() - прочитать текущий элемент без смещения указателя. Если данных нет возвращается "конец итератора"
     * ObjPtr IteratorNext(int64_t count)- прочитать заданное кол-во элементов и переместить итератор на следующий элемент. 
     * При не нулевом кол-ве, данные возвращаются как элементы словаря. Если указан кол-во элеметов 0 - возвращается текущий элемент.
     * 
     * Реализаиця итераторов NewLang с помощью данного интерфейса:
     *
     * Создание итератора
     * ?, ?("Фильтр"), ?(func), ?(func, args...)    - IteratorMake
     * 
     * Перебор элементов итератора
     * !, !(0), !(3), !(-3)
     * 
     * dict! и dict!(0) <НЕ> эквивалентны, т.к. по разному обработывают конец данных
     * dict! -> 1,  dict! -> 2, dict! -> 3, dict! -> 4, dict! -> 5, dict! -> исключение "конец итератора"
     * dict!(0) -> 1,  dict!(0) -> 2, ... dict!(0) -> 5, dict!(0) -> :IteratorEnd (может :Empty  - пустое значение ?? )
     * dict!(1) -> (1,),  dict!(1) -> (2,), ... dict!(1) -> (5,), dict!(1) -> (,)
     * 
     * Различия отрицательного размера возвращаемого словаря для итератора 
     * (Для отрцетельного размера всегда зозвращается словарь указанного размера)
     * dict!(-1) -> (1,),  ...  dict!(-1) -> (5,),  dict!(-1) -> (:IteratorEnd,),  
     * dict!(1) -> (1,),  ...  dict!(1) -> (5,),  dict!(1) -> (,),  
     * dict!(-3) -> (1, 2, 3,),  dict!(-3) -> (4, 5, :IteratorEnd,)
     * dict!(3) -> (1, 2, 3,), dict!(3) -> (4, 5,)
     * 
     * Операторы ?! и !? эквивалентны и возвращают текущие данные без перемещения указателя итератора (IteratorData) и не принимают аргументов.
     * Остальные итераторы можно вызвать либо без скобок, либо с аргментами в скобрках. Вызов без аргументов зарпрешщен 
     * (чтобы не пересекаться с логикой копирования объектов и не делать для итераторов аругменты по умолчанию)
     * 
     * Оператор ?? создает итератор и сразу его выполняет, возвращая все значения 
     * в виде элементов словаря, т.е. аналог последовательности ?(LINQ); !(:Int64.__max__);
     * 
     * Оператор !! без аргументов - сбрасывает итератор в начальное состояние (IteratorReset),
     * Обператор !! с аргументами выполняется как ! с аругментами, но с начла коллекции.



 рах  и итераторы в C++ очень сильно отличаются.

  
Требуется разделять конейнеры с данными и итераторы по данным.
В С++ контейнеры данных предоставялют итераторы, для работы с которыми требуются сами контейнеры непосредствено.
Это удобно для использования в рукописном коде, но сложно контроллировать в генерируемом исходнике, 
     * т.к. требуется использовать и итертор и сам контейнер с данными (для сравнения текущего элемента с end()).
     * 
     * Итератор - отдельный объект, которому для создания требуется контейнер с данными.
     * Итератор реализует два интерфейса перебора данных:
     * 1. - первый интерфейс итератора как в С++ 
     * 2. - второй интерфейс для использования в генерируемом коде  с логикой NewLang
     * 
     * template Iterator - Обертка над классическим С++ итератором с добавлением возможности отбора
     * элементов по имени поля или с помощь функции обратного вызова для пользовательской фильтрации.
     * 
     * Программынй интерфейс итераторов для NewLang следующий:
     * 
     * ObjPtr IteratorMake(const std::string filter) - создать итератор с возможностью фильтрации по имени поля (данные на начало)
     * ObjPtr IteratorMake(Obj * args) - создать итератор с фильтрации с помощью пользовательской функции (данные на начало)
     * ObjPtr IteratorReset() - Сбросить итератор на начало данных (возвращает сам итератор)
     * ObjPtr IteratorData() - прочитать текущий элемент без смещения указателя. Если данных нет возвращается "конец итератора"
     * ObjPtr IteratorNext(int64_t count)- прочитать заданное кол-во элементов и переместить итератор на следующий элемент. 
     * При не нулевом кол-ве, данные возвращаются как элементы словаря. Если указан кол-во элеметов 0 - возвращается текущий элемент.
     * 
     * Реализаиця итераторов NewLang с помощью данного интерфейса:
     *
     * Создание итератора
     * ?, ?("Фильтр"), ?(func), ?(func, args...)    - IteratorMake
     * 
     * Перебор элементов итератора
     * !, !(0), !(3), !(-3)
     * 
     * dict! и dict!(0) <НЕ> эквивалентны, т.к. по разному обработывают конец данных
     * dict! -> 1,  dict! -> 2, dict! -> 3, dict! -> 4, dict! -> 5, dict! -> исключение "конец итератора"
     * dict!(0) -> 1,  dict!(0) -> 2, ... dict!(0) -> 5, dict!(0) -> :IteratorEnd (может :Empty  - пустое значение ?? )
     * dict!(1) -> (1,),  dict!(1) -> (2,), ... dict!(1) -> (5,), dict!(1) -> (,)
     * 
     * Различия отрицательного размера возвращаемого словаря для итератора 
     * (Для отрцетельного размера всегда зозвращается словарь указанного размера)
     * dict!(-1) -> (1,),  ...  dict!(-1) -> (5,),  dict!(-1) -> (:IteratorEnd,),  
     * dict!(1) -> (1,),  ...  dict!(1) -> (5,),  dict!(1) -> (,),  
     * dict!(-3) -> (1, 2, 3,),  dict!(-3) -> (4, 5, :IteratorEnd,)
     * dict!(3) -> (1, 2, 3,), dict!(3) -> (4, 5,)
     * 
     * Операторы ?! и !? эквивалентны и возвращают текущие данные без перемещения указателя итератора (IteratorData) и не принимают аргументов.
     * Остальные итераторы можно вызвать либо без скобок, либо с аргментами в скобрках. Вызов без аргументов зарпрешщен 
     * (чтобы не пересекаться с логикой копирования объектов и не делать для итераторов аругменты по умолчанию)
     * 
     * Оператор ?? создает итератор и сразу его выполняет, возвращая все значения 
     * в виде элементов словаря, т.е. аналог последовательности ?(LINQ); !(:Int64.__max__);
     * 
     * Оператор !! без аргументов - сбрасывает итератор в начальное состояние (IteratorReset),
     * Обператор !! с аргументами выполняется как ! с аругментами, но с начла коллекции.


