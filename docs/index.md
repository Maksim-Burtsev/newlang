# Проект *NewLang*
*NewLang* - это язык программирования высокого уровня в котором можно сочетать стандартные алгоритмические конструкции 
с декларативным программированием и тензорными вычислениями для задач машинного обучения.

Основной особенностью языка является простой, логичный и не противоречивый синтаксис, который основан не на использовании зарезервированных ключевых слов, а на строгой системе грамматических правил с использованием знаков препинания (в которые входят и операторы языка).

Текущая версия 0.2 от ????????????.08.2022 ([Новое в текущей версии и история выпусков](https://newlang.net/version.html))

## Основные свойства и особенности языка:
- Возможность работы как в режиме интерпретатора, так и компилятора*
- Динамическая и статическая типизация с возможностью указания типов в явном виде.
- Статическая типизация является условно строгой (автоматическое приведение типов отсутствует, но допускается преобразование между некоторыми типами данных, например, целое число может быть автоматически преобразовано в вещественное или рациональное, но не наоборот)
- Автоматическое управление памятью
- ООП в виде явного наследования классов и [«утиная»](https://ru.wikipedia.org/wiki/%D0%A3%D1%82%D0%B8%D0%BD%D0%B0%D1%8F_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F) типизация
- На уровне синтаксиса поддержка нескольких типов функций (обычные и [чистые функции без побочных эффектов](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D1%82%D0%BE%D1%82%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8))
- Необязательные и именованные параметры функций
- Возможны вставки кода на языке реализации (С/С++)*
- Простая интеграция с уже существующими программными библиотеками (в том числе импорт нативных переменных и функций из С/С++.)
- Имеется REPL [read-eval-print loop — «цикл: чтение — вычисление — вывод»](https://ru.wikipedia.org/wiki/REPL)

----------
*) Данные возможности запланированы к реализации при создании компилятора

## Зачем нужен *NewLang*?

У всех современных языков программирования происходит постоянное развитие (читай усложнение) синтаксиса по мере выхода новых версий. Это является своего рода, платой за появление новых возможностей и воспринимается пользователями как естественное явление.

Но одновременно является и серьезной проблемой, т.к. с выходом новых версий добавляются новые ключевые слова и синтаксические конструкции, что неизбежно повышает порог входа для новых пользователей. Еще одним следствием этого процесса становится постоянное повышение сложности разработки и трудоемкости поддержки уже созданных программных продуктов, когда старый код дорабатывается с применением уже новых стандартов.

У *NewLang* сложность языковых конструкций естественно ограничена за счет разделения синтаксиса языка на две части, что упрощает его изучение и использование.

*Основной синтаксис* — для написания программ в объектно-ориентированном (императивном) и декларативном стилях, который основан не на зарезервированных ключевых словах, а на строгих грамматических правилах и Расширенный синтаксис — когда основного синтаксиса становится недостаточно, или требуется использовать языковую конструкцию языка реализации.

Еще одно неудобство современных мейнстримовых языков, большинство из них были созданы до начала эпохи машинного обучения, поэтому тензорные вычисления у них выполнены в виде отдельных библиотек, а не встроены в основной синтаксис языка и систему базовых типов. Это же касается и вычислений с неограниченной точностью, которая так же не поддерживается синтаксисом языка и реализуется с помощью вызовов библиотечных функций.

У *NewLang* тензорные вычисления доступны «из коробки» (используется библиотека [libtorch](https://pytorch.org/)), а арифметические типы данных являются скалярами (тензорами нулевой размерности). Так же «из коробки» и на уровне синтаксиса поддерживаются рациональные числа неограниченной точности, которые реализованы с использованием длинной арифметики из библиотеки OpenSSL.

[Синтаксис языка](https://newlang.net/syntax.html)

[Подробное описание системы типов](https://newlang.net/types.html)

[Операторы и управляющие конструкции](https://newlang.net/ops.html)


**Пример скрипта Hello world! на NewLang**
```
    #!../output/nlc --eval

    # Определение функции hello
    hello(str) := { 
      printf := :Pointer('printf(format:FmtChar, ...):Int32');  # Импорт стандартной C функции
      printf('%s', $str);  # Вызов C функции с проверкой типов аргументов по строке формата
      $str;
    };
    hello('Привет, мир!'); # Вызвать функцию
```
Вывод (первая строка выводится с помощью printf, а вторая - возвращаемое значение функции hello): 
``` 
Привет, мир!
Привет, мир!
```

**Пример скрипта для вычисления факториала 1000 на NewLang**
```
    #!../output/nlc --eval

    @fact := 1\1;  # Рациональное число без органичений точности
    @mult := 1000..1..-1?; # Получить итератор для множителей от 1000 до 2
    [mult?!] <<-->> {      # Цикл, пока не закончатся данные итератора
      fact *= mult!;  # Получить текущий множитель и перейти на следующий элемент итератора
    };
    fact # Вывести итоговый результат

```
Вывод: `402387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428646576611667797396668820291207379143853719588249808126867838374559731746136085379534524221586593201928090878297308431392844403281231558611036976801357304216168747609675871348312025478589320767169132448426236131412508780208000261683151027341827977704784635868170164365024153691398281264810213092761244896359928705114964975419909342221566832572080821333186116811553615836546984046708975602900950537616475847728421889679646244945160765353408198901385442487984959953319101723355556602139450399736280750137837615307127761926849034352625200015888535147331611702103968175921510907788019393178114194545257223865541461062892187960223838971476088506276862967146674697562911234082439208160153780889893964518263243671616762179168909779911903754031274622289988005195444414282012187361745992642956581746628302955570299024324153181617210465832036786906117260158783520751516284225540265170483304226143974286933061690897968482590125458327168226458066526769958652682272807075781391858178889652208164348344825993266043367660176999612831860788386150279465955131156552036093988180612138558600301435694527224206344631797460594682573103790084024432438465657245014402821885252470935190620929023136493273497565513958720559654228749774011413346962715422845862377387538230483865688976461927383814900140767310446640259899490222221765904339901886018566526485061799702356193897017860040811889729918311021171229845901641921068884387121855646124960798722908519296819372388642614839657382291123125024186649353143970137428531926649875337218940694281434118520158014123344828015051399694290153483077644569099073152433278288269864602789864321139083506217095002597389863554277196742822248757586765752344220207573630569498825087968928162753848863396909959826280956121450994871701244516461260379029309120889086942028510640182154399457156805941872748998094254742173582401063677404595741785160829230135358081840096996372524230560855903700624271243416909004153690105933983835777939410970027753472000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\1`



### Загрузки
[Бинарная сборка REPL (пока только под Ubuntu)](https://newlang.net/nlc)  
[Архив с необходимыми разделяемыми библиотеками](https://newlang.net/env)


## Так же можно собрать из исходников
### Подготовка репозитория
- Скачать исходники [https://github.com/rsashka/newlang](https://github.com/rsashka/newlang)
- Скачать и развернуть архив [libtorch](https://pytorch.org/) в каталоге *contrib* (PyTorch Build: Stable (1.10.*) -> Your OS: Linux -> Package: LibTorch -> Language: C++ / Java -> Compute Platform: CPU -> Download here (cxx11 ABI):
[libtorch-cxx11-abi-shared-with-deps-1.10.2+cpu.zip](https://download.pytorch.org/libtorch/cpu/libtorch-cxx11-abi-shared-with-deps-1.10.2%2Bcpu.zip))
- Активировать и скачать исходники субмодулей (`git submodule init && git submodule update`)
- В каталоге *contrib* запустить файл `build.sh`
- В каталоге *src* запустить файл `compile_syntax.sh` для генерации файлов парсера и лексического анализатора. Также может потребоваться установка утилит *flex* и *bison*. Если что, у меня установлены flex 2.6.4 и bison (GNU Bison) 3.7.4

### Сборка
- Юнит-тесты (nlc_test): в каталоге *src* выполнить команду **`make CONF=UnitTest_LLVM`** *
- Интерпретатор (nlc): в каталоге *src* выполнить команду **`make CONF=Debug_LLVM`** *
---
*) - Сборка проекта выполняется обычной утилитой make, но сборочные файлы генерируются автоматически в давно устаревшей версии NetBeans 8.2, т.к. это единственная универсальная среда разработки с поддержкой Makefile "из коробки", тогда как в текущей версии Apache NetBeans полноценная поддержка разработки на С/С++ вообще отсутствует. Начал постепеный переход на использование редактора VSCodium (аналога VSCode, в котором вычищена телеметрия от Microsoft) и генерацию скиптов сборки с помощью сmake, но этот процесс пока не завершен. 
