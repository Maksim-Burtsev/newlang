# Проект *NewLang*
*NewLang* - это язык программирования высокого уровня в котором можно сочетать стандартные алгоритмические конструкции 
с декларативным программированием и тензорными вычислениями для задач машинного обучения.

Основной особенностью языка является простой, логичный и не противоречивый синтаксис, который основан не на использовании зарезервированных ключевых слов, а на строгой системе грамматических правил с использованием знаков препинания (в список которых входят и операторы языка).

## Основные свойства и особенности языка:
- Возможность работы как в режиме интерпретатора, так и компилятора*
- Динамическая и статическая типизация с возможностью указания типов в явном виде. 
- Статическая типизация является условно строгой (автоматическое приведение типов отсутствует, но допускается преобразование между некоторыми типами данных, например, целое число может быть автоматически преобразовано в вещественное, но не наоборот)
- Автоматическое управление памятью
- ООП в виде явного наследования классов и [«утиная»](https://ru.wikipedia.org/wiki/%D0%A3%D1%82%D0%B8%D0%BD%D0%B0%D1%8F_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F) типизация
- На уровне синтаксиса поддержка нескольких типов функций (обычные и [чистые функции без побочных эффектов](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D1%82%D0%BE%D1%82%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8))
- Необязательные и именованные параметры функций
- Возможны вставки кода на языке реализации (С/С++)*
- Простая интеграция с уже существующими программными библиотеками (в том числе импорт нативных переменных и функций из С/С++.)
- Имеется REPL [read-eval-print loop — «цикл: чтение — вычисление — вывод»](https://ru.wikipedia.org/wiki/REPL)

----------
*) Данные возможности запалнированы к реализации при создании компилятора

## Зачем нужен *NewLang*?
У всех современных языков программирования происходит постоянное развитие (читай усложнение) синтаксиса по мере выхода новых версий. Это является своего рода, платой за появление новых возможностей и воспринимается пользователями как естественное явление.

Но одновременно является и серьезной проблемой, т.к. с выходом новых версий добавляются новые ключевые слова и синтаксические конструкции, что неизбежно повышает порог входа для новых пользователей. Еще одним следствием этого процесса становится постоянное повышение сложности разработки и трудоемкости поддержки уже созданных программных продуктов, когда старый код дорабатывается с применением уже новых стандартов.

У *NewLang* сложность языковых конструкций естественно ограничена за счет разделения синтаксиса языка на две части, что упрощает его изучение и использование. 

*Основной синтаксис* — для написания программ в объектно-ориентированном (императивном) и декларативном стилях, который основан не на зарезервированных ключевых словах, а на строгих грамматических правилах и *Расширенный синтаксис* — когда основного синтаксиса становится недостаточно, или требуется использовать языковую конструкцию языка реализации.

Еще одно неудобство современных мейнстримовых языков, большинство из них были созданы до начала эпохи машинного обучения, поэтому тензорные вычисления у них выполнены в виде отдельных библиотек, а не встроены в основной синтаксис языка и систему базовых типов. 

У *NewLang* тензорные вычисления доступны «из коробки» (используется библиотека [libtorch](https://pytorch.org/)), а арифметические типы данных являются скалярами (тензорами нулевой размерности).

### Основной синтаксис
Основной синтаксис *NewLang* - простой и логичный за счет того, что он построен исключительно на грамматических правилах и не использует каких либо зарезервированных ключевых слов, а все буквенно-символьные последовательности рассматриваются как идентификаторы в которых можно использовать любые не-ASCII символы.

Идеализированная цель отказа от ключевых слов, приблизить чтение исходного текста программы при описании логики работы алгоритма к чтению обычного текста за счет использования знаков препинания.

> конечно *запятая* человек может вычленять ключевые управляющие слова языка и *слеш* или учитывать форматирование программы *запятая* чтобы на их основе понимать синтаксические конструкции *запятая* хотя при обычном чтении мы привыкли опирается именно на семантику знаков препинания *точка* мы конечно можем писать знаки препинания и обычным текстом *запятая* но согласитесь *запятая* что тогда *открытая скобка* например *запятая* вот такой вот текст *закрытая скобка* будет очень не удобно читать *точка*

Названия встроенных типов или имена служебных функции системной библиотеки определяются конкретной реализацией языка, поэтому не являются зарезервированными ключевыми словами и при необходимости могут быть переопределены, например, для создания собственного, предметно-ориентированного диалекта (DSL - domain-specific language). Но сама структура программы и логика выполняемого алгоритма все равно останутся понятны всем, кто знаком правилами основного синтаксиса *NewLang*.

### Расширенный синтаксис
Расширенный синтаксис — это возможность вставить в текст программы *NewLang* исходнй код на языке реализации, что позволяет использовать практически любые возможности С/С++. 

Обработка расширенного синтаксиса происходит на этапе компиляции приложения, а взаимодействие между основным 
и расширенным синтаксисами происходит за счет совместного использования идентификаторов, которое полностью прозрачно для пользователя и подчиняется единым грамматическим правилам основного синтаксиса.

*Пример скрипта Hello world! на NewLang*
```
    #!./nlc --eval 
    # Определение функции hello
    hello(str) := { 
      printf := @import('printf(format:Format, ...):Int');  # Импорт стандартной C функции
      printf('%s\n', $str);  # Вызов C функции с проверкой типов аргументов по строке формата
    };
    hello('Привет, мир!'); # Вызвать функцию
```
Вывод: `Привет, мир!`

## Еще немного примеров:
Любая последовательность вычислений возвращает результат выполнения последнего оператора.
Поэтому выполнение одной команды или последовательности команд всегда возвращает какой либо результат, а оператор возврата из функции необязателен, так как результатом будет значение последнего вычисленного выражения.

### Создание переменных
    > scalar := 42
    42

    > tensor := [1,2,3,4,5,]  # Тип тензора выводится автоматически
    [1, 2, 3, 4, 5,]:Char
               
    > str := '$1 string'  # Создание байтовой строки
    $1 string

### Арифметические операции
    > tensor * 2
    [2, 4, 6, 8, 10,]:Short
    
    > tensor * 20
    [20, 40, 60, 80, 100,]:Short
    
    > tensor * 0.5
    [0.5, 1, 1.5, 2, 2.5,]:Double
    
    > tensor / 2 # Результата деления — число с плавающей точкой
    [0.5, 1, 1.5, 2, 2.5,]:Double

    > tensor // 2 # Целочисленное деление без остатка
    [0, 1, 1, 2, 2,]:Char

    > tensor % 2 # Целочисленный остаток от деления
    [1, 0, 1, 0, 1,]:Char
    
### Строковые операции
    > str = 'сцепеление строк ' ++ str
    сцепеление строк $1 string

    > str('строка как шаблон') #  символ $1 в строке заменяется на первый аргумент
    сцепеление строк строка как шаблон string
   
## Преобразование данных
В эпоху машинного обучения тензоры являются основным элементом вычислений, поэтому функции создания и преобразования типов обязательно должны поддерживать тензоры. Данная поддержка заключается в следующим:

Название типов данных должно начинатся на символ двоеточия, а операция создания данных заданного типа заключается в записи нужного типа даннх в виде вызова функции, т.е. :Int(10) - создает скаляр указанного типа с значением 10.

А так как тензоры могту иметь больше одного значения, то и в качестве аргументов можно передавать более одного значения и результатом будет тензор содержащий указанные значения с автоматическим преобразованим переданных значений к требуемому типу.

Подробнее про особенности преобразования типов можно посмотреть в [полном описании синтаксиса](https://github.com/rsashka/newlang/blob/master/Syntax.md).
  
    > tstr := :Tensor("Тест");   # Создать тензор из строки широких символов
    [1058, 1077, 1089, 1090,]:Int

    > t2 := :Tensor[2,2]("Тест"); # Тоже самое, но тензор указанной размерности
    [
      [1058, 1077,], [1089, 1090,],
    ]:Int

    > :StrWide(tstr) # Создать символьную строку из тензора
    Тест

    > :Double(t2)    # Изменить тип данных тезора без изменения размерности
    [
      [1058, 1077,], [1089, 1090,],
    ]:Double

    > t3 := :Char[4]( t2 ) # Изменить размерность тензора и его тип (в данном случае с частичной потерей данных)
    [34, 53, 65, 66,]:Char


## [Полное описание синтаксиса](https://newlang.net/syntax.html)


## Сборка REPL из исходников (пока только под Linux)
### Подготовка репозитория
- Скачать исходники [https://github.com/rsashka/newlang](https://github.com/rsashka/newlang)
- Скачать и развернуть архив [libtorch](https://pytorch.org/) в каталоге *contrib* (PyTorch Build: Stable (1.10.*) -> Your OS: Linux -> Package: LibTorch -> Language: C++ / Java -> Compute Platform: CPU -> Download here (cxx11 ABI):
[libtorch-cxx11-abi-shared-with-deps-1.10.2+cpu.zip](https://download.pytorch.org/libtorch/cpu/libtorch-cxx11-abi-shared-with-deps-1.10.2%2Bcpu.zip))
- Активировать и скачать исходники субмодулей (`git submodule init && git submodule update`)
- В каталоге *contrib* запустить файл `build.sh` для сборки библиотеки libffi
- В каталоге *core* запустить файл `compile_syntax.sh` для генерации файлов парсера и лексического анализатора. Также может потребоваться установка утилит *flex* и *bison*. Если что, у меня установлены flex 2.6.4 и bison (GNU Bison) 3.7.4


### Собрать
- Юнит-тесты (newlang_test): в каталоге *core* выполнить команду **`make CONF=UnitTest`** *
- Интерпретатор (nlc): в каталоге *core* выполнить команду **`make CONF=Debug`** *
---
*) - Сборка проекта выполняется обычной утилитой make, но сборочные файлы генерируются автоматически в давно устаревшей версии NetBeans 8.2, т.к. это единственная универсальная среда разработки с поддержкой Makefile "из коробки", тогда как в текущей версии Apache NetBeans полноценная поддержка разработки на С/С++ вообще отсутствует. Начал постепеный переход на использование редактора VSCodium (аналога VSCode, в котором вычищена телеметрия от Microsoft) и генерацию скиптов сборки с помощью сmake, но этот процесс пока не завершен. 


# Планы на будущее
Текущая версия, это скорее тестовая платформа для проверки декларируемых концепций и основного синтаксиса. Если говорить о планах, то в настоящий момент роадмап развития NewLang следующий:
- Добавить в язык макросы для более простого использовани за счет использования концепции DSL
- Реализовать длинную арифметику и дроби
- Сделать какую нибудь логическую игру (крестики нолики, судоку или что-то похожее) с алгоритмическим выбором следующего хода и его вычислением с помощью машинного обучения.
- Написать много разных примеров для оценки синтаксиса.
- Доработать синтаксис с учетом полученного опыта и обратной связи.
- Восстановить работоспособность компилятора для генерации исполняемых файлов.
- Сделать очередную большую чистку кода.
- Переработать и задокументировать получившуюся семантику языка с учетом всех возможностей и выпустить первую полнофункциональную версию NewLang.

