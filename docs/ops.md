Основные свойства и особенности языка:
    • Возможность работы как в режиме интерпретатора, так и компилятора 
    • Динамическая и статическая типизация с возможностью указания типов в явном виде. Статическая типизация является условно строгой (автоматическое приведение типов отсутствует, но допускается автоматическое преобразование между некоторыми типами данных, например, целое число может быть автоматически преобразовано в вещественное, но не наоборот) 
    • Автоматическое управление памятью 
    • ООП в виде явного наследования классов и «утиная» типизация 
    • На уровне синтаксиса поддержка нескольких типов функций (обычные и чистые функции без побочных эффектов) 
    • Необязательные и именованные параметры функций 
    • Возможны вставки кода на языке реализации (С/С++) 
    • Простая интеграция с уже существующими программными библиотеками (в том числе импорт нативных переменных и функций из С/С++.) 
    • Имеется REPL read-eval-print loop — «цикл: чтение — вычисление — вывод» 

Краткое описание грамматики 

Комментарии:
# однострочный
/* */ многострочный

Строчные и прописные буквы различаются. 
Идентификаторы могут состоять из произвольного числа букв, цифр и символов подчеркивания и должены начинаться с не цифрового символа.

Литералы:
Широки и байтовые строки "" ''
Числа 
Тензоры [,]
Словари (,)
Длинные числа `100`100
Дроби  1\1

Перед идентификатором может быть указан специальный символ, который отвечает за назначение объекта.
$ на стеке, @ в куче, : тип данных, \ макрос, % константа????,

Операторы создания:
= 
:=
::=


Арифметические операторы:
+ - * / - арифметические 
// целочисленное деление
%  остаток от деления
** возведение в степень

Операторы сравнения типов:
~ ~~  ~~~

Логические операторы:
< > = == === != !== !===

Операторы изменения типов (один и тот же функционал, но разная форма операторов):
[[ ]] преобразования типа (по умолчанию в тензор с автоматическим выводом типа). Можно преобразовать в любой тип
++  конкатенация (автоматический выбор типа отсутствует). Добавляется к существующим данным/типу
[,]:Int[4] ++ var;

Управляющие конструкции:

Следование
Через ;
выход (прерывание выполнения) 
--
{}
{{ }}

Проверка условия
[] -> {} или [] --> {}

Проверка соответствия
[val] ==> {
  [val]-> {};
  [val, val2]-> {};
  [_]-> {};
}

Цикл пока
[] ->> {} или [] -->> {}

Цикл до
{} <<- [] или {} <<-- []


   use crypto::sha256;
   use encoding::hex;
   use fmt;
   use hash;
   use io;
   use os;

   export fn main() void = {
	const hash = sha256::sha256();
	const file = os::open("main.ha")!;
	defer io::close(file);
	io::copy(&hash, file)!;

	let sum: [sha256::SIZE]u8 = [0...];
	hash::sum(&hash, sum);
	hex::encode(os::stdout, sum)!;
	fmt::println()!;




	const greetings = [
		"Hello, world!",
		"¡Hola Mundo!",
		"Γειά σου Κόσμε!",
		"Привет, мир!",
		"こんにちは世界！",
	];
	for (let i = 0z; i < len(greetings); i += 1) {
		fmt::println(greetings[i])!;
	};




	let x: *int = alloc(42);
	fmt::printfln(" x: {}", x)!;
	fmt::printfln("*x: {}", *x)!;
	free(x);

	const file = os::open(os::args[1])!;
	defer io::close(file)!;

	let buffer: *[65535]u8 = alloc([0...]);
	defer free(buffer);

	const n = io::read(file, buffer)! as size;
	io::write(os::stdout, buffer[..n])!;

   };

   fn sort(items: []int) void = {
      ...
   };

   @test fn sort() void = {
	let items = [5, 4, 3, 2, 1];
	sort(items);
	for (let i = 1z; i < len(items); i += 1) {
		assert(items[i - 1] <= items[i], "list is unsorted");
	};
   };