# Синтаксис NewLang
При разработки синтаксиса я старался придерживаться уже сложившихся основных правил синтаксиса, стараясь не создавать множественных смыслов, зависящих от контекста.

## Основы
- Каждый оператор завершается точкой с запятой «;».
- Отступы и переводы строк игнорируются, т. к. очень хотелось иметь возможность автоматического форматирование кода.
- Многострочные комментарии в исходном коде соответствуют стилю С/С++ и должны располагаться между символами /* и */. Вложенность многострочных комментариев не поддерживается.
- Однострочные комментарии начинаются на # до перевода строки, что соответствует комментариям в Python и Bash
- Последовательность команд, которая описывает последовательность выполняемых команд и/или должна выполняться как единое целое заключается в фигурные скобки «{}».
- Программные вставки расширенного синтаксиса на языке реализации заключается в фигурные скобки со знаком процента %{ /* тут может быть любой код на C/C++*/ %}

## Создания объектов и присвоения новых значений
Для создания объектов и присвоения значений в NewLang используется сразу три разных оператора. Оператор «::=» используется только для создания объектов и если объект с таким именем уже существует, то генерируется ошибка.
Оператор «:=» используется для тех же целей, но если объект с таким именем уже существует, то ошибки не происходит, а новое значение присваивается уже существующему объекту. И последний оператор «=» применяется только для присвоения значения уже существующим объектам, и если объект с указанным именем отсутствует происходит ошибка. 
Использование трех разных операторов для создания объектов и присвоения им значений позволяет явно указывать требуемую операцию и выявлять логические ошибки в коде на более раннем этапе.

var ::= 1.0; # Создать новую переменную var без указания типа
var = 100; # Присвоить новое значение уже существующей переменной
printf := @import('printf(format:Format, ...):Int'); # Создать новый или переопределить объект printf, который будет результатом выполнения глобальной функции @import


## Идентификаторы объектов и модификаторы
В качестве идентификаторов объектов можно использовать буквы, цифры и знак подчеркивания в любых комбинациях, при условии, что первый символ идентификатора не является цифрой. 

В качестве особенностей идентификаторов NewLang можно отметить возможность указания области видимости и времени существования объекта (модификатор - специальный символ перед именем переменной). Это может показаться немного похожим на венгерскую нотацию, но в отличие от нее, модификатор не имеет отношения к типу объекта и не является частью имени идентификатора. К тому же в качестве модификаторов используется строго определённые символы, назначение которых определено заранее.

Так, символ «$» в начале имени отмечает локальную переменную, время жизни которой ограничена только текущей областью видимости и при выходе из текущей области видимости такая переменная уничтожается. Символ «@» обозначает глобальную переменную, а сам объект сохраняет свое состояние даже после выхода из текущей области видимости. Для указания типа (и для создания новых типов объектов) в качестве модификатора символа двоеточия «:» (типы объектов всегда создаются в глобальной области видимости, а их имена должны быть уникальными).

Семантика обращения к аргументам функций очень похоже на работу с аргументами в bash скриптах, где $1 или $arg - номер или имя аргумента. Остальные особенности объектов с указанием модификаторами и без оных будут приведены далее при описании различных функций. 


## Система типов языка
Так как система типов языка динамическая, то явное указание типа не влияет на размер используемой памяти в переменной и является только своего рода ограничением на возможность присвоения переменной значения другого типа. 

Информация о типах используется при проверке их совместимости, когда существующей  переменной присваивается значение другого типа. Такая операция возможна только когда типы между собой совместимы и допускают автоматическое приведение. Это справедливо как во время парсинга/компиляции исходного теста, так и во время выполнения в режимах интерпретатора и скомпилированного файла.

### Арифметические типы:

Арифметические типы данных реализованы как тензоры - массивы чисел одного типа с произвольным количеством измерений и одинаковым размером столбцов в каждом. Единичное число тоже является тензором, только нулевого размера.
Поддерживаются только знаковые целые числа, т. к. в беззнаковых числах особая нужда отсутствует, а проблем с ними на ровном месте можно найти очень много.

Проблемы беззнаковых чисел!
Во-первых, вычитание двух беззнаковых чисел, например 3 и 5. 3 минус 5 равно 4294967294, т.к. -2 не может быть представлено как беззнаковое число.
Во-вторых, непредвиденное поведение может возникнуть при смешивании целочисленных значений со знаком и без знака.
С++ может свободно преобразовывать числа со знаком и без знака, но не проверяет диапазон, чтобы убедиться, что вы не переполняете свой тип данных.

В C++ всё же есть несколько случаев, когда можно (или необходимо) использовать беззнаковые числа.
Во-первых, числа без знака предпочтительнее при работе с битами.
Во-вторых, использование беззнаковых чисел связаных с индексацией массивов. 
(не в текущем случае, так как индекс может быть отрицатльным и даже не числом, а диапазоном или многоточием)


- Встроенные названия арифметических типов говорят сами за себя: Char, Short, Int, Long, Float, Double, ComplexFloat, ComplexDouble. Отдельным типом идет логический тип Bool, который может принимать значения только 0 или 1 (false/true соответственно), и в зависимости от выполняемой операции может быть отнесен к целочисленным типам, так и не входить в их состав (данный подход в интрепретации логического типа данных был взят из библиотеки Torch). В будущем планирую добавить числа для длинной арифметики и дроби, для чего зарезервированы названия типов Decimal, Fraction.

Доступ к элементам тензора происходит по целочисленному индексу, который начинается с 0. Для многомерного тензора, индексы элемента перечисляются в квадратных скобках через запятую. Поддерживается доступ к элементам через отрицательный индекс, который обрабатывается точно так же как и в Python (-1 последний элемент, -2 предпоследний и т.д.). 

Литерал тензор в тексте программы записывается в квадратных скобках с обязательной завершающей запятой, т. е. [1, 2,] - это литерал одномерный тензор из двух чисел. После закрывающей скобки тип тензора литерала может быть указан в явном виде. Если тип тензора не указан, то он выводится автоматически на основании указанных в тензоре данных, принимая минимально возможный байтовый размер, который позволяет сохранить все значения без потери точности.

*Примеры:*
    $var_char := 123; # Тип Char выводится автоматически
    $var_short := 1000; # Тип Short выводится автоматически
    $var_bool := [0, 1, 0, 1,]; # Тензор из 4 элементов. Тип Bool выводится автоматически
    $tensor[10,10]:Int := 1; # Тензор Int размером 2x2 инициализированный 1
    $scalar := $tensor[5,5]; # Присвоить скаляру значение указанного элемента тензора

### Строковые типы данных:
- Поддерживаются два типа строк, символьные (широкие) и байтовые. Различия между ними заключается типе единичного элемента. У символьных строк единичным элементом строки является широкий символ wchar_t (его размерность зависит от реализации), а у байтовой строки единичным элементом является один байт. Символьные строки литералы в исходном тексте записывается в «двойных кавычках», а байтовые строки в «одинарных кавычках». 

Количество элементов символьной строки возвращается в широких символах, а размер байтовой строки в байтах, соответственно и обращение к элементу строки по индексу происходить в соответствии с типом строки, либо к символу, либо к байту.

Важный момент. К любой переменной можно обратиться так же как к функции (указав после её имени круглые скобки). Результатом этой операции будет создание копии/клона объекта. Причем  некоторые типы объектов (словари, классы и символьные строки) можно использовать в качестве шаблона при создания копии объекта с модифицированными свойствами, если новые или изменяемые значения передать в скобках при клонировании как аргументы. Так, если при создании копии в скобках указать набор параметров, то результирующая копия будет содержать уже измененные данные, переданные в скобках как аргументы при копировании.

*Например:*
    template := «${name} $1»; # Обычная строка
    result := template(«шаблон», name = «Строка»); # result = «Строка шаблон»


### Составные типы данных:
#### Словарь
Словарь — набор данных произвольного типа с доступ к отдельным элементам по целочисленному индексу или по имени элемента при его наличии. Словари от тензоров отличаются тем, что являются только одномерными массивами, но каждый элемент может содержать произвольное количество элементов любого типа, в том числе и другие словари.
Доступ к элементам словарей происходит по целочисленному индексу, который начинается с 0, либо по имени элемента, которое записывается через точку от имени переменной. 
Литерал с типом «словарь» в тексте программы записывается в круглых скобках с обязательной завершающей запятой, т. е. (,) - пустой словарь,  (1, 2= «2», name=3,).
#### Класс
Класс — Тип данных, с помощью которого реализуется один из принципов ООП - наследование. При создании экземпляра класса, создается новая переменная, у которой сохраняется информацию о своем родителе и которая наследует от него свойства и методы. Тип данных «класс» аналогичен словарю, но все свойства класса обязаны иметь имена (хотя доступ к свойствам класса по индексу так же возможен).
Литерал с типом «Класс» в тексте программы записывается в круглых скобках без завершающей запятой, т. е. () - пустой класс,  (1, 2= «2», name=3).

#### Перечисление
Перечисление —  Это не отдельный тип данных, а обычный словарь, у которого все элементы имеют уникальные имена и целочисленные значение, которое указывается явно или вычисляется автоматически на единицу больше предыдущего элемента. У перечисления тип значения может быть указан сразу для всех элементов (ONE=1, TWO=, THREE=): Int.

Класс литерал в тексте программы указывается в круглых скобках без завершающей запятой, после которого может быть указано имя базового класса или нескольких классов через запятую. 
:new_class := (field_empty=_,  field_int=3): base1(arg1), base2(arg2);


к т. е. ():class_name — новый пустой класс «class_name» или класс (field_empty=,  field_int=3), с двумя полями и именем по умолчанию. 

методы, которые определяются внутри класса, могут проверять имена полей объектов во время компиляции приложения.
Методы, котрые определены вне тела класса, не могут проверять имена полей класса во время компиляции.
И первые, и вторые можно вызывать для конкретного объекта, так и без объекта (как статические функции), 
а доступ к полям объекта будет определяется способом вызова,
и при вызове метода без объекта, нулевой метода аргумент будет пустым.


Класс литерал в тексте программы указывается в круглых скобках без завершающей запятой, после которого может быть указано имя класса, т. е. ():class_name — новый пустой класс «class_name» или класс (field_empty=,  field_int=3), с двумя полями и именем по умолчанию. 

Создание нового экземпляра класса происходит при обращении к переменной с базовым классом, как к функции с указанием круглых скобок после её имени. Поэтому создание экземпляра класса семантически ничем не отличается от вызова функции.

Если требуется создать не экземпляр класса, а новый класс, то его название указывается после закрывающей скобки через двоеточие. По умолчанию в качестве имени класса используется имя базового класса или имя переменной, если имя класса явно не указано.


*Примеры:*
    dict := (one=1,2,3,); # Переменная dict из трех элементов
    monkey := (sex=); # Класс monkey
    human := monkey(parent=[,]):human; # Новый класс human
    human1  := human(sex=male); # Экземпляр класса human


### Функции:
Синтаксис NewLang поддерживать несколько типов функций (а в будущем и методов классов): Обычные функции, чистые функции и простые чистые функции.

Для всех типов функций поддерживаются аргументы по умолчанию. При создании функции, её аргументы указываются как в Питоне, т. е. вначале идут обязательные аргументы, потом аргументы со значениями по умолчанию, для которых имя аргумента отделяется от значения по умолчанию знаком равно «=». Если функция допускает обработку произвольного количества аргументов, то последним в списке параметров нужно указать многоточие. 

#### Обычная функция
Обычная функция — функции являются именно обычными функциями в понимании С/С++. Внутри них можно писать совершенно любой код, включая проверки условий, циклы, вызовы других функций и т.д. 


Технически, код такой функции парсится на предмет замены использованных аргументов, специальным образом декорируется её имя и добавляются специальные маркеры для идентификации содержимого. После этого исходный текст готов для сборки обычным С++ компилятором для превращения в динамическую библиотеку. А после её загрузки в память, функцию можно будет вызвать в любой момент.

Внутри обычной функции можно обращаться к сессионным и глобальным объектам и могут содержаться вставки на языке реализации, например для вызова функций из внешних библиотек. Вставки на языке реализации оформляются в виде %{     %} и могут содержать внутри себя совершенно любой текст на С/С++, который не разбирается парсером NewLang, а просто преобразуется трансплайтером непосредственно в исходный текст генерируемого файла для последующей компиляции. 
Причем в программных вставках можно обращаться к локальным и глобальным объектам так же, как и в обычном синтаксисе, указывая первым символом имени идентификатора соответствующими модификатор ($ для локальных объектов и @ для глобальных).

*Например:*
    printf(str) := { %{ std::cout « $str; %} }; # Вывести аргумент в стандартный поток вывода

#### Чистая функция 
Чистая функция — чистая функция, это тоже обычная функция, только в том смысле, какой вкладывается в него функциональное программирование. Создания чистой функции происходит с помощью оператора «:-». У чистой функции отсутствует доступ к контексту и глобальным объектам, поэтому она может обрабатывать только те данные, которые были ей переданы в аргументах.

Программные вставки на языке реализации внутри чистых функций выполняются на страх и риск разработчика. Именно он отвечает за их «чистоту», например при вызове функций из внешних библиотек. 

Sum(arg1, arg2) :- {$arg1+$arg2;}; # Вернуть сумму аргументов

В языке отсутствует оператор возврата данных из текущего блока выполнения (аналог оператора return <данные>), а возвращаемым значением функции / блока кода всегда является результат выполнения последней операции.

Простые чистые функции — отдельный класс чистых функций которые предназначены только для вычисления логического результата (предикаты) и отличаются упрощенной формой записи. Тело простой чистой функции состоит из последовательности логических условий, которые разделяются запятыми и заканчиваются как и любой оператор точкой с запятой. Все условия простой чистой функции всегда приводятся к логическому значению, а итоговый результат функции вычисляется по одной из возможных операций:  логическое И, логическое ИЛИ и исключающее ИЛИ.

*Например:*
    func_and(arg1, arg2) &&= arg1==3, arg2 > 0;  # Простая чистая функция Логическое И
    func_or(arg1, arg2) ||= arg1==3, arg2 > 0; # Простая чистая функция Логическое ИЛИ
    func_xor(arg1, arg2) ^^= arg1==3, arg2 > 0;  # Простая чистая функция Исключающее ИЛИ


## Специальные типы данных:

### пустой тип
- None (пустой тип) — не содержит значения (точнее имеет одно значение None) и совместим с любым другим типом данных. Указывается в тексте программы как один подчерк «_». Значение None имеют не инициализированные переменные и при попытке чтения из такой переменной возникает ошибка.

Тип переменной может быть явно указан или выведен автоматически из присваиваемого значения. Присвоить новое значение уже инициализированной переменной можно только для совместимого типа, так как неявное преобразование типов не допускаются.

    var := _; # Создать переменную со значением None
    var2 := var; # Ошибка!!! Нельзя прочитать не инициализированную переменную var
    var = 1000; # У переменной будет тип Short (минимальный размер для хранения значения)
    var = 0,5; # Ошибка!!! Short ← Float не совместимы
    var = _; # Очистить значение перемной
    var = 0,5; # Теперь можно, т. к. None совместим с любым типом

### Диапазон 
Диапазон — специальный тип данных, являющейся приблизительным аналогом типа «генератор» в Python. К диапазону можно обращаться как к итератору и он будет поочередно выдавать элементы в указанном интервале с заданным шагом. Диапазон в тексте программы указывается как два или три элемента через двоеточие, например 1..5 — диапазон он единицы до пяти с шагом по умолчанию 1. В качестве параметров диапазона можно указывать не только литералы, но и имена переменных. Например,  0,1..$stop..0,1 — диапазон от значения 0,1 до значения, указанного в переменой $stop с шагом 0,1.

Диапазон для целых чисел можно использовать в качестве индекса у тензоров (точнее, у любых объектов, которые допускают доступ к своим элементам по индексу, т. е. тензоры, словари и текстовые строки). Фактический, это поведение аналогично slice в языке Python и array[1:5] в Питоне означает тоже самое, что и array[1..5].

В качестве индекса у тензоров еще можно указать произвольное количество измерений с помощью многоточия, т. е. tensor[…, 0] = 0; # Обнулить все первые элементы в каждом измерении.

### Итераторы
Итераторы - самый сложный и неоднозначный тип данных для работы с элементами коллекций.  Для работы с итераторами зарезервированы символы ! И ?, но сами итераторы пока не реализованы. 


## Операторы

### Арифметические операторы
Все арифметические операторы имеют парный оператор с присвоением значения.

+ и += сложение арифметических типов данных
- и -= вычитание арифметических типов данных
/ и /= деление (результат число с плавающей точной)
// и //= целочисленное деление с округлением к меньшему числу (как в Python)
* и *= умножение
** и **=  возведение в степень
++ и ++= конкатенация строк с автоматическим приведением правого аргумента к стоковому типу левого аргумента (чтобы в явном виде разделить объединение строк и операторы арифметического сложения)

### Конкатенация строк
++ и ++= конкатенация строк с автоматическим приведением правого аргумента к стоковому типу левого аргумента (чтобы в явном виде разделить объединение строк и операторы арифметического сложения)

### Операторы сравнения
<, >, <=, >=  классические для сравнения скаляров
==, != операторы сравнения с автоматическим приведением совместимых типов для любых объектов
===, !== оператор точного сравнения для любых объектов (автоматического приведения типов не выполняется)

### Проверки типов:
Проверка имени класса «~» - немного похож на оператор instanceof в Java. Левым оператором должен быть проверяемый объект, а правым оператором, строка литерал или объект строкового типа с именем класса. Результатом операции будет истина, если правый операнд содержит название класса проверяемого объекта или он присутствует в иерархии наследования у проверяемого класса.

Утиная типизация «~~» - приблизительный аналог функции isinstance() в  Python, который для простых типов сравнивается совместимость типа левого операнда по отношению к правому, а для словарей и классов в левом операдне проверяется наличие всех имен полей, присутствующих у правого операнда. т. е. 
(field1=«value», field2=2, field3=«33»,) ~~ (); # Истина (т. е. левый операнд словарь)
(field1=«value», field2=2, field3=«33»,) ~~ (field1=_); # Тоже истина (т. к. поле field1 присутствует у левого операнда)

Строгая утиная типизация «~~~» - для простых типов сравнивается идентичности типов без учета совместимости, а для составных типов происходит строгое сравнение всех свойств. Для данной операции, пустой тип совместим только с другим пустим типом!

## Управляющие конструкции

### Условный оператор

В качестве оператора проверки условия используется синтаксическая конструкция, соответствующая по смыслу термину «следует», т.е. тире и угловая скобка «→». Такая запись условного оператора очень похожа на математическую и легко объединяется в последовательности для реализации проверки множественных условий вида «else if». 

В общем случае условный оператор в новом языке программирования имеет вид:
условие -> действие;
или  
(условие) -> {действие};
или  
(условие1 || условие2) -> {действие} -> {действие иначе};
Или расширенный вариант «else if», для наглядности записанный с отступами:
(условие1) -> {действие1}
        (условие2) -> {действие2}
        (условие3) -> {действие3}
        -> {действие_иначе};

### Операторы циклов
Операторы циклов записываются практически аналогично, только в качестве оператора используется следование с возвратом (т. к. это действие циклическое).

Цикл пока:
(условие) <-> {тело цикла};

Цикл со счетчиком пока реализуется через обычный цикл с проверкой условия:
$array := (1,2,3,4,5,6,7,8,);
$counter := 0..@count($array); |$array| ?????????????????? |- |-
$index := _;
($index = $counter()) <->{
	print($array[$index]);
}

Такой синтаксис мне самому очень не нравится, но я решил пока не ломать над этим голову и планирую «облагородить» цикл со счетчиком одновременно с реализацией итераторов.


### Операторы прерывания потока выполнения команд
Оператором прерывания потока выполнения команд и возврата из текущей функции, т. е. самым близким аналогом оператора return  является оператор два символа минус «--». Но в отличии от классического return, оператор возврата не возвращает значения. Значение из любой функции или блока кода возвращается всегда и им является результат выполнения самой последней операции (или None, если такая операция отсутствует).
Оператором прерывания потока выполнения команд в случае ошибки (при его выполнении происходит генерация исключения), является любое выражение, записанное между символами «[-» и «-]», т. е. [- описание ошибки или объект для вывода в дамп -];
Отдельных операторов goto, break и сontinue в простом синтаксисе не поддерживается (по крайне	й мене пока), но если без них не получается запрограммировать логику, то можно использовать вставки на языке реализации, т. е. %{ label:; %}, %{ goto label; %}, %{ break; %} и %{ сontinue; %}.

< метка >;
| метка >;
|>;
<|;
::= ??????????